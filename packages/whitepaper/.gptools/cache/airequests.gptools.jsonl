{"sha":"50cca088d1d9c576aaa40a30d5c157d3861092f1538d643503d360808fab5aaa","key":{"template":{"id":"front-matter","title":"SEO front matter"},"fragment":{"fullId":"gptools-overview.md.gpspec.md:0:0","hash":"b7521b7869f54be8"}},"val":{"response":{"edits":[],"fileEdits":{"/workspaces/coarch/packages/whitepaper/gptools-overview.md":{"before":"---\ntitle: gptools: Empowering Human Workflows with AI-Enhanced Tools\ndescription: An overview of gptools, a framework that empowers teams to create and use AI-enhanced scripts to support their workflows.\n---\n# gptools: Empowering Human Workflows with AI-Enhanced Tools\n\n-   Authors: Peli de Halleux, Michał Moskal, Ben Zorn\n-   Date: October 2023\n-   Repository: [gptools](https://github.com/microsoft/gptools/tree/main)\n\n## Abstract\n\ngptools is a framework that empowers teams, including non-developers, to create and use AI-enhanced scripts to support their workflows. gptools provides support for creating, understanding, and maintaining complex collections of documents such as software repositories, project management, etc. Our framework leverages foundation models (specifically LLMs) to enable a new kind of scripting that combines traditional code and natural language. The key elements of the gptools framework are **gpspecs** and **gptools**. gpspecs are natural language documents that describe specific user tasks to accomplish. gptools are general scripts that combine traditional software and natural language prompts and rely on an LLM to generate results. We execute gptools in the context of a gpspec to achieve a result. By separating these two abstractions, we allow gptools to be authored, maintained, and updated independently of the gpspecs that use them. The gptools framework includes an execution engine to execute a gptool and an IDE extension to VS Code to support user interaction with the gptool. We believe that gptools will empower even non-developers to automate their workflows in ways that were previously impossible.\n\n## Introduction\n\nThis document describes the gptools framework, which empowers teams, including non-developers, to use AI-enhanced scripts to support their efforts in creating, understanding, and maintaining complex artifacts. gptools leverages foundation models (LLMs) to enable a new kind of scripting that combines traditional code and natural language. To understand how gptools works, we provide an example. The key elements of gptools include gpspecs, gptools, the gpvm, and the gptools extension to VS code.\n\n```mermaid\ngraph LR\nF[User:\\nvia VSCode\\n UI] --> G[gpspec:\\nwrite email\\n recognizer]\nG --> A[gptool:\\ngenerate\\npython code]\nA --> C[gpvm pre:\\nexpand gpspec\\nand gptool\\ninto prompt]\nC --> D[Foundation Model]\nD --> E[gpvm post:\\nextract\\npython code]\nE --> F\n```\n\nThis diagram illustrates the workflow of gptools with a concrete example. The user wants to write a python function that recognizes well-formed email addresses and writes a gpspec. She then invokes a gptool, one that will generate python code from a spec, on that gpspec, much as a user might call a python script with some arguments. The gpvm composes the gpspec with the gptool creating an LLM prompt, which in turn is passed to the foundation model. The foundation model returns a result (python code) to the gpvm, which postprocesses it, creates the requested python file, and notifies the user.\n\nThis document will motivate the design of the gptools framework, illustrate its use with examples, and describe elements of implementation.\n\n## Complex Artifacts Require Complex Workflows\n\n-   Software development is a complex process that requires the coordination of many different activities.\n-   Historically, software development has been a highly manual process, with developers using a variety of tools to create and maintain the artifacts that comprise a software system.\n-   Over time abstractions have been developed to help manage the complexity of software development.\n    -   Important examples include: Unix utilities and pipes, makefiles, build scripts, etc.\n-   Modern software development includes many automated processes as well as manual processes such as code review, design review, bug triage, etc.\n\n## Foundation Models Create New Opportunities\n\n-   The recent development of foundation models (aka LLMs) have created new opportunities for automating complex workflows.\n-   AI has important advantages over traditional software:\n    -   AI models can perform tasks normal software cannot\n    -   AI models can be instructed using natural language, allowing non-programmers to use them\n-   AI models also have disadvantages:\n    -   AI models are not perfect, and can make mistakes\n    -   AI models are not transparent, and it is difficult to understand why they make the decisions they do\n-   AI models are best used to augment human workflows, not replace them\n\n## gptools - a Framework for AI-Enhanced Workflows\n\nVision: empower teams, including non-developers, to use AI-enhanced scripts to support their efforts to create, understand, and maintain complex artifacts\n\nGoals: support tool abstraction, modularity, reuse, but at the same time empower non-developers to author, maintain, and update AI-enhanced scripts\n\nApproach: Foundation models enable a new kind of scripting that allows script writers to achieve both greater functionality and greater ease of use. We separate scripts into two related parts: a generic reusable _gptool_ and a natural language _gpspec_ that instantiates the gptool in a particular context\n\nKey elements of gptools:\n\n-   _gptools_ – Scripts that integrate traditional code and natural language and leverage foundation models in their execution\n-   _gpspecs_ – Natural language documents that instantiate gptools in a particular context\n-   _gpvm_ – A framework and runtime system that executes gpspecs and gptools\n-   _gptools extension to VS code_ – supporting seamless user interaction with gptools\n\n## gptool: A New Kind of Script\n\n-   A gptool is a script with the following components\n\n    -   A header that contains metadata related to the execution of the script (e.g., information about what LLM model to use, etc.)\n    -   A natural language prompt intended to be processed by a foundation model\n    -   An environment context that augments the natural language with additional data/information\n    -   Programming language constructs that are used to programmatically manipulate both inputs and outputs\n\n-   Benefits of gptools\n    -   By separating the gptool from the gpspec, we allow gptools to become highly engineered shared artifacts, forming the basis of shared libraries.\n    -   A gptool can be used in many different contexts, and can be updated and maintained independently of the gpspecs that use it.\n    -   By separating the gptool from the gpspec, we allow non-developers to use gptools without having to understand the details of how they work.\n    -   At the same time, because a gptool contains a natural language prompt, it is easy for a non-developer to understand what the gptool does, and to modify it to suit their needs.\n\n## gpspec: Natural Language to Invoke a gptool\n\nJust as a chat enables a user to interact with an AI model, a gpspec is a natural language markdown document that defines a context in which to invoke a gptool.\n\nA gpspec is a standard markdown file, with the following additional elements:\n\n-   Links to context elements that define the context in which a particular gptool is to be invoked. For example, a gpspec might contain links to markdown files, code files, etc.\n-   Natural language describing the specific task to be performed as input to a gptool. For example, the spec used to generate code would include a description of the functionality and might include a description style guidelines to observe, etc.\n\n. A single gpspec file might be used as input to multiple gptools. For example, a gpspec might be used to generate code, documentation, and tests, each using a different gptool.\n\n## Expanding the Example\n\nTo better understand how gptools work, we expand the example given above. The diagram below illustrates the gptools workflow in greater detail. Our design of gptools is based on the following principles:\n\n-   gptools are used in a context where there is human oversight on the content generated. As a result, our workflow starts and ends with the user.\n-   We assume that the output of a gptool may be incomplete or incorrect, and that the user will need to interact with the output to refine it. As a result, we allow the user to accept/reject and directly modify the AI-generated content.\n-   We assume that the user will want to understand how the AI model was used to generate the results. We provide a trace of how the gpvm composes the gpspec and gptool into a prompt that can be processed by the foundation model.\n-   We support iterative development, where the user can both edit the gpspec and the gptool if they see opportunities to improve the results.\n\n```mermaid\nsequenceDiagram\nparticipant User\nparticipant VSCode\nparticipant gpspec\nparticipant gptool\nparticipant gpvm\nUser->>VSCode: Create/Edit gpspec\nVSCode->>gpspec: Save gpspec\nUser->>VSCode: Invoke gptool\nVSCode->>gptool: Execute gptool with gpspec context\ngptool->>gpvm: Request foundation model execution\ngpvm->>gptool: Return AI-generated output\ngptool->>VSCode: Update context with output\nVSCode->>User: Display updated context\n```\n\nThis diagram demonstrates the AI-enhanced workflow process in gptools. The gpspec instantiates the gptool, which interacts with the gpvm and foundation model. The AI-generated output is used to update the context, and the user interacts with the updated context through the gptools extension to VS code.\n\n### gptool Example: Python Developer gptool\n\nThis is an example of a simple gptool that generates python code from a gpspec file:\n\n```javascript\ngptool({\n    title: \"Generate python code\",\n    model: \"gpt-4\",\n    description: \"Given a task, generate python code.\",\n})\n\ndef(\n    \"CODE\",\n    env.links.filter(\n        (f) => f.filename.endsWith(\".py\") && !f.filename.startsWith(\"test_\")\n    )\n)\ndef(\"TASK\", env.file)\n\n$`Generate python code for the task in TASK. Save code in CODE. If the CODE is already present, ensure that CODE matches the description in TASK and make changes to CODE if it does not.`\n```\n\nIn this example we see the following elements:\n\n-   A header that contains metadata related to the execution of the script (e.g., information about what LLM model to use, etc.)\n-   JavaScript code that manipulates the environment context, specifically by extracting only the python files from the context that do not start with \"test\\_\".\n-   Variable definitions that allow the prompt to refer to elements in the context. TASK refers to the gpspec file, and CODE refers to the python files in the context.\n-   Natural language that combines these elements.\n\n### gpspec Example: Using the Python Developer gptool\n\nThis is an example of a gpspec file that uses the python generating gptool shown above:\n\n```markdown\n# email address and URL recognizer\n\nWrite a function that takes a string argument and returns true if the whole string is a valid email address, false otherwise.\n```\n\nIn this example, there is no additional context needed to invoke the python developer gptool. In other cases, the gpspec file will contain links to additional context elements, such as markdown, code files, etc.\n\n## gpvm - A Framework for Executing gpspecs and gptools\n\nEvery system that interacts with a foundation model includes layers that transform user input into a prompt that can be processed by the foundation model, and layers that transform the output of the foundation model into a form that is useful to the user.\n\n-   gpvm is a runtime environment that:\n    -   Captures the context defined by the gpspec\n    -   Executes whatever code is present in the gptool (in the example above, the variables CODE and TASK are defined by executing JavaScript code)\n    -   Expands the gpspec and natural language of the gptool into a prompt that can be processed by the foundation model\n    -   Sends the results to the AI model\n    -   Processes the results on return to update the user context (which might include creating files, updating files, generating user feedback, etc.)\n\nUnlike many AI model orchestration frameworks, such as Semantic Kernel, gpvm does not leverage the model to do chain-of-thought reasoning or utomatically stage multiple invocations of the AI model during its execution. gptools currently relies on the user to choose and invoke the appropriate gptool as needed.\n\n## gptools Extension to VS Code\n\nWe believe that human oversight of AI models is essential to their effective use. To support this, we have created a VS Code extension that allows a user to interact with a gpspec and gptool in a natural way.\n\nThe extension provides the following capabilities:\n\n-   A command palette that allows a user to select a gptool to invoke in the context of a given gpspec file\n-   A token management system that supports connecting with the AI model of interest\n-   An invocation of the gpvm to process the user input and generate results\n-   A user interface that allows the user to interact with the AI model to refine the results\n-   A gptool trace viewing mechanism that allows users to understand how the AI model was used to generate the results\n\n## Implications of gptools\n\nThe existence of powerful programming tools based on AI that are usable by non-developers is transformative.\n\nJust as the development of JavaScript enabled Web 2.0, and python enabled the creation of the current AI software ecosystem, gptools will fuel a new generation of AI-enhanced applications.\n\nWe envision the creation of gptools for many different verticals, with opportunities for customization and authoring at many levels of expertise:\n\n-   Professional developers and architects will define collections of gptools for a given vertical just as packages are authored and maintained today\n-   Professional developers can author and maintain individual gptools\n-   Developers and non-developers can customize gptools for their particular organization or application needs\n-   Non-developers can author and maintain gpspecs for their particular projects\n\nFurthermore, the existence of gptools can empower non-developers to automate their workflows in ways that were previously impossible.\n\n## Related Work\n\ngptools are related to a number of foundation model projects that automate workflows and encapsulate LLM actions in software artifacts. We describe some of these projects below:\n\n### AI Tools for Developers\n\n-   [GitHub Copilot](https://copilot.github.com/) is a VS Code extension that uses the Codex LLM to suggest code completions based on the context of the current file. Copilot provides LLM support for writing code but does not currently have an extensibility model or a way to create, maintain and apply collections of AI-enhanced scripts.\n-   [codeplan](https://arxiv.org/abs/2309.12499) is a task-agnostic framework that frames repository-level coding as a planning problem, synthesizing a multi-step chain of edits where each step results in a call to an LLM on a code location with context derived from the entire repository, previous code changes, and task-specific instructions. While codeplan uses LLM prompts to generate code, it does not provide a way to create, maintain and apply collections of AI-enhanced scripts.\n\n### LLM Automation/Orchestration Frameworks\n\n-   [autogpt](https://github.com/Significant-Gravitas/AutoGPT) is an AI agent that utilizes a large language model to drive its actions and decisions. Unlike traditional language model applications, AutoGPT does not require repeated prompting by a human and can autonomously develop and manage tasks.\n-   [langchain](https://www.langchain.com/) is a Python library designed to simplify the development of Natural Language Processing (NLP) applications using large language models. It provides a framework for connecting language models to other sources of data and allowing them to interact with their environment.\n-   [semantic kernel](https://github.com/microsoft/semantic-kernel) is an open-source SDK that allows developers to easily integrate AI services with conventional programming languages such as C# and Python. It provides a framework for connecting language models to other sources of data, allowing them to interact with their environment and perform tasks autonomously.\n-   [autogen](https://arxiv.org/abs/2308.08155) is a framework for simplifying the orchestration, optimization, and automation of large language model (LLM) workflows. It offers customizable and conversable agents that leverage LLMs while addressing their limitations by integrating with humans and tools and having conversations between multiple agents via automated chat.\n\ngptools differ from existing AI task automation frameworks in the following ways:\n\n-   gptools are designed to be authored, maintained, and applied by non-developers as well as developers.\n-   gptools define a separation between the gptool and the gpspec that instantiates it, allowing for modularity, reuse, and easier understanding by non-developers.\n-   gptools do not assume task automation and provide a user experience that integrates seamlessly with VS code.\n-   The gptools UI exposes both the content and execution of each gptools to facilitate human oversight and understanding of how the AI model was used to generate the results.\n","after":"---\ntitle: gptools: Empowering Human Workflows with AI-Enhanced Tools\ndescription: An overview of gptools, a framework that empowers teams to create and use AI-enhanced scripts to support their workflows.\n---\n# gptools: Empowering Human Workflows with AI-Enhanced Tools\n\n-   Authors: Peli de Halleux, Michał Moskal, Ben Zorn\n-   Date: October 2023\n-   Repository: [gptools](https://github.com/microsoft/gptools/tree/main)\n\n## Abstract\n\ngptools is a framework that empowers teams, including non-developers, to create and use AI-enhanced scripts to support their workflows. gptools provides support for creating, understanding, and maintaining complex collections of documents such as software repositories, project management, etc. Our framework leverages foundation models (specifically LLMs) to enable a new kind of scripting that combines traditional code and natural language. The key elements of the gptools framework are **gpspecs** and **gptools**. gpspecs are natural language documents that describe specific user tasks to accomplish. gptools are general scripts that combine traditional software and natural language prompts and rely on an LLM to generate results. We execute gptools in the context of a gpspec to achieve a result. By separating these two abstractions, we allow gptools to be authored, maintained, and updated independently of the gpspecs that use them. The gptools framework includes an execution engine to execute a gptool and an IDE extension to VS Code to support user interaction with the gptool. We believe that gptools will empower even non-developers to automate their workflows in ways that were previously impossible.\n\n## Introduction\n\nThis document describes the gptools framework, which empowers teams, including non-developers, to use AI-enhanced scripts to support their efforts in creating, understanding, and maintaining complex artifacts. gptools leverages foundation models (LLMs) to enable a new kind of scripting that combines traditional code and natural language. To understand how gptools works, we provide an example. The key elements of gptools include gpspecs, gptools, the gpvm, and the gptools extension to VS code.\n\n```mermaid\ngraph LR\nF[User:\\nvia VSCode\\n UI] --> G[gpspec:\\nwrite email\\n recognizer]\nG --> A[gptool:\\ngenerate\\npython code]\nA --> C[gpvm pre:\\nexpand gpspec\\nand gptool\\ninto prompt]\nC --> D[Foundation Model]\nD --> E[gpvm post:\\nextract\\npython code]\nE --> F\n```\n\nThis diagram illustrates the workflow of gptools with a concrete example. The user wants to write a python function that recognizes well-formed email addresses and writes a gpspec. She then invokes a gptool, one that will generate python code from a spec, on that gpspec, much as a user might call a python script with some arguments. The gpvm composes the gpspec with the gptool creating an LLM prompt, which in turn is passed to the foundation model. The foundation model returns a result (python code) to the gpvm, which postprocesses it, creates the requested python file, and notifies the user.\n\nThis document will motivate the design of the gptools framework, illustrate its use with examples, and describe elements of implementation.\n\n## Complex Artifacts Require Complex Workflows\n\n-   Software development is a complex process that requires the coordination of many different activities.\n-   Historically, software development has been a highly manual process, with developers using a variety of tools to create and maintain the artifacts that comprise a software system.\n-   Over time abstractions have been developed to help manage the complexity of software development.\n    -   Important examples include: Unix utilities and pipes, makefiles, build scripts, etc.\n-   Modern software development includes many automated processes as well as manual processes such as code review, design review, bug triage, etc.\n\n## Foundation Models Create New Opportunities\n\n-   The recent development of foundation models (aka LLMs) have created new opportunities for automating complex workflows.\n-   AI has important advantages over traditional software:\n    -   AI models can perform tasks normal software cannot\n    -   AI models can be instructed using natural language, allowing non-programmers to use them\n-   AI models also have disadvantages:\n    -   AI models are not perfect, and can make mistakes\n    -   AI models are not transparent, and it is difficult to understand why they make the decisions they do\n-   AI models are best used to augment human workflows, not replace them\n\n## gptools - a Framework for AI-Enhanced Workflows\n\nVision: empower teams, including non-developers, to use AI-enhanced scripts to support their efforts to create, understand, and maintain complex artifacts\n\nGoals: support tool abstraction, modularity, reuse, but at the same time empower non-developers to author, maintain, and update AI-enhanced scripts\n\nApproach: Foundation models enable a new kind of scripting that allows script writers to achieve both greater functionality and greater ease of use. We separate scripts into two related parts: a generic reusable _gptool_ and a natural language _gpspec_ that instantiates the gptool in a particular context\n\nKey elements of gptools:\n\n-   _gptools_ – Scripts that integrate traditional code and natural language and leverage foundation models in their execution\n-   _gpspecs_ – Natural language documents that instantiate gptools in a particular context\n-   _gpvm_ – A framework and runtime system that executes gpspecs and gptools\n-   _gptools extension to VS code_ – supporting seamless user interaction with gptools\n\n## gptool: A New Kind of Script\n\n-   A gptool is a script with the following components\n\n    -   A header that contains metadata related to the execution of the script (e.g., information about what LLM model to use, etc.)\n    -   A natural language prompt intended to be processed by a foundation model\n    -   An environment context that augments the natural language with additional data/information\n    -   Programming language constructs that are used to programmatically manipulate both inputs and outputs\n\n-   Benefits of gptools\n    -   By separating the gptool from the gpspec, we allow gptools to become highly engineered shared artifacts, forming the basis of shared libraries.\n    -   A gptool can be used in many different contexts, and can be updated and maintained independently of the gpspecs that use it.\n    -   By separating the gptool from the gpspec, we allow non-developers to use gptools without having to understand the details of how they work.\n    -   At the same time, because a gptool contains a natural language prompt, it is easy for a non-developer to understand what the gptool does, and to modify it to suit their needs.\n\n## gpspec: Natural Language to Invoke a gptool\n\nJust as a chat enables a user to interact with an AI model, a gpspec is a natural language markdown document that defines a context in which to invoke a gptool.\n\nA gpspec is a standard markdown file, with the following additional elements:\n\n-   Links to context elements that define the context in which a particular gptool is to be invoked. For example, a gpspec might contain links to markdown files, code files, etc.\n-   Natural language describing the specific task to be performed as input to a gptool. For example, the spec used to generate code would include a description of the functionality and might include a description style guidelines to observe, etc.\n\n. A single gpspec file might be used as input to multiple gptools. For example, a gpspec might be used to generate code, documentation, and tests, each using a different gptool.\n\n## Expanding the Example\n\nTo better understand how gptools work, we expand the example given above. The diagram below illustrates the gptools workflow in greater detail. Our design of gptools is based on the following principles:\n\n-   gptools are used in a context where there is human oversight on the content generated. As a result, our workflow starts and ends with the user.\n-   We assume that the output of a gptool may be incomplete or incorrect, and that the user will need to interact with the output to refine it. As a result, we allow the user to accept/reject and directly modify the AI-generated content.\n-   We assume that the user will want to understand how the AI model was used to generate the results. We provide a trace of how the gpvm composes the gpspec and gptool into a prompt that can be processed by the foundation model.\n-   We support iterative development, where the user can both edit the gpspec and the gptool if they see opportunities to improve the results.\n\n```mermaid\nsequenceDiagram\nparticipant User\nparticipant VSCode\nparticipant gpspec\nparticipant gptool\nparticipant gpvm\nUser->>VSCode: Create/Edit gpspec\nVSCode->>gpspec: Save gpspec\nUser->>VSCode: Invoke gptool\nVSCode->>gptool: Execute gptool with gpspec context\ngptool->>gpvm: Request foundation model execution\ngpvm->>gptool: Return AI-generated output\ngptool->>VSCode: Update context with output\nVSCode->>User: Display updated context\n```\n\nThis diagram demonstrates the AI-enhanced workflow process in gptools. The gpspec instantiates the gptool, which interacts with the gpvm and foundation model. The AI-generated output is used to update the context, and the user interacts with the updated context through the gptools extension to VS code.\n\n### gptool Example: Python Developer gptool\n\nThis is an example of a simple gptool that generates python code from a gpspec file:\n\n```javascript\ngptool({\n    title: \"Generate python code\",\n    model: \"gpt-4\",\n    description: \"Given a task, generate python code.\",\n})\n\ndef(\n    \"CODE\",\n    env.links.filter(\n        (f) => f.filename.endsWith(\".py\") && !f.filename.startsWith(\"test_\")\n    )\n)\ndef(\"TASK\", env.file)\n\n$`Generate python code for the task in TASK. Save code in CODE. If the CODE is already present, ensure that CODE matches the description in TASK and make changes to CODE if it does not.`\n```\n\nIn this example we see the following elements:\n\n-   A header that contains metadata related to the execution of the script (e.g., information about what LLM model to use, etc.)\n-   JavaScript code that manipulates the environment context, specifically by extracting only the python files from the context that do not start with \"test\\_\".\n-   Variable definitions that allow the prompt to refer to elements in the context. TASK refers to the gpspec file, and CODE refers to the python files in the context.\n-   Natural language that combines these elements.\n\n### gpspec Example: Using the Python Developer gptool\n\nThis is an example of a gpspec file that uses the python generating gptool shown above:\n\n```markdown\n# email address and URL recognizer\n\nWrite a function that takes a string argument and returns true if the whole string is a valid email address, false otherwise.\n```\n\nIn this example, there is no additional context needed to invoke the python developer gptool. In other cases, the gpspec file will contain links to additional context elements, such as markdown, code files, etc.\n\n## gpvm - A Framework for Executing gpspecs and gptools\n\nEvery system that interacts with a foundation model includes layers that transform user input into a prompt that can be processed by the foundation model, and layers that transform the output of the foundation model into a form that is useful to the user.\n\n-   gpvm is a runtime environment that:\n    -   Captures the context defined by the gpspec\n    -   Executes whatever code is present in the gptool (in the example above, the variables CODE and TASK are defined by executing JavaScript code)\n    -   Expands the gpspec and natural language of the gptool into a prompt that can be processed by the foundation model\n    -   Sends the results to the AI model\n    -   Processes the results on return to update the user context (which might include creating files, updating files, generating user feedback, etc.)\n\nUnlike many AI model orchestration frameworks, such as Semantic Kernel, gpvm does not leverage the model to do chain-of-thought reasoning or utomatically stage multiple invocations of the AI model during its execution. gptools currently relies on the user to choose and invoke the appropriate gptool as needed.\n\n## gptools Extension to VS Code\n\nWe believe that human oversight of AI models is essential to their effective use. To support this, we have created a VS Code extension that allows a user to interact with a gpspec and gptool in a natural way.\n\nThe extension provides the following capabilities:\n\n-   A command palette that allows a user to select a gptool to invoke in the context of a given gpspec file\n-   A token management system that supports connecting with the AI model of interest\n-   An invocation of the gpvm to process the user input and generate results\n-   A user interface that allows the user to interact with the AI model to refine the results\n-   A gptool trace viewing mechanism that allows users to understand how the AI model was used to generate the results\n\n## Implications of gptools\n\nThe existence of powerful programming tools based on AI that are usable by non-developers is transformative.\n\nJust as the development of JavaScript enabled Web 2.0, and python enabled the creation of the current AI software ecosystem, gptools will fuel a new generation of AI-enhanced applications.\n\nWe envision the creation of gptools for many different verticals, with opportunities for customization and authoring at many levels of expertise:\n\n-   Professional developers and architects will define collections of gptools for a given vertical just as packages are authored and maintained today\n-   Professional developers can author and maintain individual gptools\n-   Developers and non-developers can customize gptools for their particular organization or application needs\n-   Non-developers can author and maintain gpspecs for their particular projects\n\nFurthermore, the existence of gptools can empower non-developers to automate their workflows in ways that were previously impossible.\n\n## Related Work\n\ngptools are related to a number of foundation model projects that automate workflows and encapsulate LLM actions in software artifacts. We describe some of these projects below:\n\n### AI Tools for Developers\n\n-   [GitHub Copilot](https://copilot.github.com/) is a VS Code extension that uses the Codex LLM to suggest code completions based on the context of the current file. Copilot provides LLM support for writing code but does not currently have an extensibility model or a way to create, maintain and apply collections of AI-enhanced scripts.\n-   [codeplan](https://arxiv.org/abs/2309.12499) is a task-agnostic framework that frames repository-level coding as a planning problem, synthesizing a multi-step chain of edits where each step results in a call to an LLM on a code location with context derived from the entire repository, previous code changes, and task-specific instructions. While codeplan uses LLM prompts to generate code, it does not provide a way to create, maintain and apply collections of AI-enhanced scripts.\n\n### LLM Automation/Orchestration Frameworks\n\n-   [autogpt](https://github.com/Significant-Gravitas/AutoGPT) is an AI agent that utilizes a large language model to drive its actions and decisions. Unlike traditional language model applications, AutoGPT does not require repeated prompting by a human and can autonomously develop and manage tasks.\n-   [langchain](https://www.langchain.com/) is a Python library designed to simplify the development of Natural Language Processing (NLP) applications using large language models. It provides a framework for connecting language models to other sources of data and allowing them to interact with their environment.\n-   [semantic kernel](https://github.com/microsoft/semantic-kernel) is an open-source SDK that allows developers to easily integrate AI services with conventional programming languages such as C# and Python. It provides a framework for connecting language models to other sources of data, allowing them to interact with their environment and perform tasks autonomously.\n-   [autogen](https://arxiv.org/abs/2308.08155) is a framework for simplifying the orchestration, optimization, and automation of large language model (LLM) workflows. It offers customizable and conversable agents that leverage LLMs while addressing their limitations by integrating with humans and tools and having conversations between multiple agents via automated chat.\n\ngptools differ from existing AI task automation frameworks in the following ways:\n\n-   gptools are designed to be authored, maintained, and applied by non-developers as well as developers.\n-   gptools define a separation between the gptool and the gpspec that instantiates it, allowing for modularity, reuse, and easier understanding by non-developers.\n-   gptools do not assume task automation and provide a user experience that integrates seamlessly with VS code.\n-   The gptools UI exposes both the content and execution of each gptools to facilitate human oversight and understanding of how the AI model was used to generate the results.\n"}},"trace":"\n# `front-matter` trace\n\n\n\n## gptool source\n\n\n```js\ngptool({\n    title: \"SEO front matter\",\n    description:\n        \"Update or generate SEO-optimized front matter for a markdown file.\",\n    categories: [\"samples\"],\n    system: [\"system\", \"system.diff\", \"system.summary\"],\n    maxTokens: 2000,\n    temperature: 0,\n})\n\ndef(\n    \"FILE\",\n    env.links.filter((f) => f.filename.endsWith(\".md\")), { lineNumbers: true }\n)\n\n$`\nYou are a search engine optimization expert at creating front matter for markdown document.\n\nUpdate or generate front matter in FILE:\n- Update fields title, description and keywords as needed\n- use yaml format, do not use quotes\n- only 5 keywords or less\n- optimize for search engine optimization.\n- Do NOT modify the markdown content after the front matter\n\nIf no front matter is present, generate it.\n`\n```\n\n\n\n## console output\n> tip: use `console.log()` from gptool.js files\n## expanded prompt\n\n``````markdown\nFILE:\n````` file=gptools-overview.md\n[1] ---\n[2] title: gptools: Empowering Human Workflows with AI-Enhanced Tools\n[3] description: An overview of gptools, a framework that empowers teams to create and use AI-enhanced scripts to support their workflows.\n[4] ---\n[5] # gptools: Empowering Human Workflows with AI-Enhanced Tools\n[6] \n[7] -   Authors: Peli de Halleux, Michał Moskal, Ben Zorn\n[8] -   Date: October 2023\n[9] -   Repository: [gptools](https://github.com/microsoft/gptools/tree/main)\n[10] \n[11] ## Abstract\n[12] \n[13] gptools is a framework that empowers teams, including non-developers, to create and use AI-enhanced scripts to support their workflows. gptools provides support for creating, understanding, and maintaining complex collections of documents such as software repositories, project management, etc. Our framework leverages foundation models (specifically LLMs) to enable a new kind of scripting that combines traditional code and natural language. The key elements of the gptools framework are **gpspecs** and **gptools**. gpspecs are natural language documents that describe specific user tasks to accomplish. gptools are general scripts that combine traditional software and natural language prompts and rely on an LLM to generate results. We execute gptools in the context of a gpspec to achieve a result. By separating these two abstractions, we allow gptools to be authored, maintained, and updated independently of the gpspecs that use them. The gptools framework includes an execution engine to execute a gptool and an IDE extension to VS Code to support user interaction with the gptool. We believe that gptools will empower even non-developers to automate their workflows in ways that were previously impossible.\n[14] \n[15] ## Introduction\n[16] \n[17] This document describes the gptools framework, which empowers teams, including non-developers, to use AI-enhanced scripts to support their efforts in creating, understanding, and maintaining complex artifacts. gptools leverages foundation models (LLMs) to enable a new kind of scripting that combines traditional code and natural language. To understand how gptools works, we provide an example. The key elements of gptools include gpspecs, gptools, the gpvm, and the gptools extension to VS code.\n[18] \n[19] ```mermaid\n[20] graph LR\n[21] F[User:\\nvia VSCode\\n UI] --> G[gpspec:\\nwrite email\\n recognizer]\n[22] G --> A[gptool:\\ngenerate\\npython code]\n[23] A --> C[gpvm pre:\\nexpand gpspec\\nand gptool\\ninto prompt]\n[24] C --> D[Foundation Model]\n[25] D --> E[gpvm post:\\nextract\\npython code]\n[26] E --> F\n[27] ```\n[28] \n[29] This diagram illustrates the workflow of gptools with a concrete example. The user wants to write a python function that recognizes well-formed email addresses and writes a gpspec. She then invokes a gptool, one that will generate python code from a spec, on that gpspec, much as a user might call a python script with some arguments. The gpvm composes the gpspec with the gptool creating an LLM prompt, which in turn is passed to the foundation model. The foundation model returns a result (python code) to the gpvm, which postprocesses it, creates the requested python file, and notifies the user.\n[30] \n[31] This document will motivate the design of the gptools framework, illustrate its use with examples, and describe elements of implementation.\n[32] \n[33] ## Complex Artifacts Require Complex Workflows\n[34] \n[35] -   Software development is a complex process that requires the coordination of many different activities.\n[36] -   Historically, software development has been a highly manual process, with developers using a variety of tools to create and maintain the artifacts that comprise a software system.\n[37] -   Over time abstractions have been developed to help manage the complexity of software development.\n[38]     -   Important examples include: Unix utilities and pipes, makefiles, build scripts, etc.\n[39] -   Modern software development includes many automated processes as well as manual processes such as code review, design review, bug triage, etc.\n[40] \n[41] ## Foundation Models Create New Opportunities\n[42] \n[43] -   The recent development of foundation models (aka LLMs) have created new opportunities for automating complex workflows.\n[44] -   AI has important advantages over traditional software:\n[45]     -   AI models can perform tasks normal software cannot\n[46]     -   AI models can be instructed using natural language, allowing non-programmers to use them\n[47] -   AI models also have disadvantages:\n[48]     -   AI models are not perfect, and can make mistakes\n[49]     -   AI models are not transparent, and it is difficult to understand why they make the decisions they do\n[50] -   AI models are best used to augment human workflows, not replace them\n[51] \n[52] ## gptools - a Framework for AI-Enhanced Workflows\n[53] \n[54] Vision: empower teams, including non-developers, to use AI-enhanced scripts to support their efforts to create, understand, and maintain complex artifacts\n[55] \n[56] Goals: support tool abstraction, modularity, reuse, but at the same time empower non-developers to author, maintain, and update AI-enhanced scripts\n[57] \n[58] Approach: Foundation models enable a new kind of scripting that allows script writers to achieve both greater functionality and greater ease of use. We separate scripts into two related parts: a generic reusable _gptool_ and a natural language _gpspec_ that instantiates the gptool in a particular context\n[59] \n[60] Key elements of gptools:\n[61] \n[62] -   _gptools_ – Scripts that integrate traditional code and natural language and leverage foundation models in their execution\n[63] -   _gpspecs_ – Natural language documents that instantiate gptools in a particular context\n[64] -   _gpvm_ – A framework and runtime system that executes gpspecs and gptools\n[65] -   _gptools extension to VS code_ – supporting seamless user interaction with gptools\n[66] \n[67] ## gptool: A New Kind of Script\n[68] \n[69] -   A gptool is a script with the following components\n[70] \n[71]     -   A header that contains metadata related to the execution of the script (e.g., information about what LLM model to use, etc.)\n[72]     -   A natural language prompt intended to be processed by a foundation model\n[73]     -   An environment context that augments the natural language with additional data/information\n[74]     -   Programming language constructs that are used to programmatically manipulate both inputs and outputs\n[75] \n[76] -   Benefits of gptools\n[77]     -   By separating the gptool from the gpspec, we allow gptools to become highly engineered shared artifacts, forming the basis of shared libraries.\n[78]     -   A gptool can be used in many different contexts, and can be updated and maintained independently of the gpspecs that use it.\n[79]     -   By separating the gptool from the gpspec, we allow non-developers to use gptools without having to understand the details of how they work.\n[80]     -   At the same time, because a gptool contains a natural language prompt, it is easy for a non-developer to understand what the gptool does, and to modify it to suit their needs.\n[81] \n[82] ## gpspec: Natural Language to Invoke a gptool\n[83] \n[84] Just as a chat enables a user to interact with an AI model, a gpspec is a natural language markdown document that defines a context in which to invoke a gptool.\n[85] \n[86] A gpspec is a standard markdown file, with the following additional elements:\n[87] \n[88] -   Links to context elements that define the context in which a particular gptool is to be invoked. For example, a gpspec might contain links to markdown files, code files, etc.\n[89] -   Natural language describing the specific task to be performed as input to a gptool. For example, the spec used to generate code would include a description of the functionality and might include a description style guidelines to observe, etc.\n[90] \n[91] . A single gpspec file might be used as input to multiple gptools. For example, a gpspec might be used to generate code, documentation, and tests, each using a different gptool.\n[92] \n[93] ## Expanding the Example\n[94] \n[95] To better understand how gptools work, we expand the example given above. The diagram below illustrates the gptools workflow in greater detail. Our design of gptools is based on the following principles:\n[96] \n[97] -   gptools are used in a context where there is human oversight on the content generated. As a result, our workflow starts and ends with the user.\n[98] -   We assume that the output of a gptool may be incomplete or incorrect, and that the user will need to interact with the output to refine it. As a result, we allow the user to accept/reject and directly modify the AI-generated content.\n[99] -   We assume that the user will want to understand how the AI model was used to generate the results. We provide a trace of how the gpvm composes the gpspec and gptool into a prompt that can be processed by the foundation model.\n[100] -   We support iterative development, where the user can both edit the gpspec and the gptool if they see opportunities to improve the results.\n[101] \n[102] ```mermaid\n[103] sequenceDiagram\n[104] participant User\n[105] participant VSCode\n[106] participant gpspec\n[107] participant gptool\n[108] participant gpvm\n[109] User->>VSCode: Create/Edit gpspec\n[110] VSCode->>gpspec: Save gpspec\n[111] User->>VSCode: Invoke gptool\n[112] VSCode->>gptool: Execute gptool with gpspec context\n[113] gptool->>gpvm: Request foundation model execution\n[114] gpvm->>gptool: Return AI-generated output\n[115] gptool->>VSCode: Update context with output\n[116] VSCode->>User: Display updated context\n[117] ```\n[118] \n[119] This diagram demonstrates the AI-enhanced workflow process in gptools. The gpspec instantiates the gptool, which interacts with the gpvm and foundation model. The AI-generated output is used to update the context, and the user interacts with the updated context through the gptools extension to VS code.\n[120] \n[121] ### gptool Example: Python Developer gptool\n[122] \n[123] This is an example of a simple gptool that generates python code from a gpspec file:\n[124] \n[125] ```javascript\n[126] gptool({\n[127]     title: \"Generate python code\",\n[128]     model: \"gpt-4\",\n[129]     description: \"Given a task, generate python code.\",\n[130] })\n[131] \n[132] def(\n[133]     \"CODE\",\n[134]     env.links.filter(\n[135]         (f) => f.filename.endsWith(\".py\") && !f.filename.startsWith(\"test_\")\n[136]     )\n[137] )\n[138] def(\"TASK\", env.file)\n[139] \n[140] $`Generate python code for the task in TASK. Save code in CODE. If the CODE is already present, ensure that CODE matches the description in TASK and make changes to CODE if it does not.`\n[141] ```\n[142] \n[143] In this example we see the following elements:\n[144] \n[145] -   A header that contains metadata related to the execution of the script (e.g., information about what LLM model to use, etc.)\n[146] -   JavaScript code that manipulates the environment context, specifically by extracting only the python files from the context that do not start with \"test\\_\".\n[147] -   Variable definitions that allow the prompt to refer to elements in the context. TASK refers to the gpspec file, and CODE refers to the python files in the context.\n[148] -   Natural language that combines these elements.\n[149] \n[150] ### gpspec Example: Using the Python Developer gptool\n[151] \n[152] This is an example of a gpspec file that uses the python generating gptool shown above:\n[153] \n[154] ```markdown\n[155] # email address and URL recognizer\n[156] \n[157] Write a function that takes a string argument and returns true if the whole string is a valid email address, false otherwise.\n[158] ```\n[159] \n[160] In this example, there is no additional context needed to invoke the python developer gptool. In other cases, the gpspec file will contain links to additional context elements, such as markdown, code files, etc.\n[161] \n[162] ## gpvm - A Framework for Executing gpspecs and gptools\n[163] \n[164] Every system that interacts with a foundation model includes layers that transform user input into a prompt that can be processed by the foundation model, and layers that transform the output of the foundation model into a form that is useful to the user.\n[165] \n[166] -   gpvm is a runtime environment that:\n[167]     -   Captures the context defined by the gpspec\n[168]     -   Executes whatever code is present in the gptool (in the example above, the variables CODE and TASK are defined by executing JavaScript code)\n[169]     -   Expands the gpspec and natural language of the gptool into a prompt that can be processed by the foundation model\n[170]     -   Sends the results to the AI model\n[171]     -   Processes the results on return to update the user context (which might include creating files, updating files, generating user feedback, etc.)\n[172] \n[173] Unlike many AI model orchestration frameworks, such as Semantic Kernel, gpvm does not leverage the model to do chain-of-thought reasoning or utomatically stage multiple invocations of the AI model during its execution. gptools currently relies on the user to choose and invoke the appropriate gptool as needed.\n[174] \n[175] ## gptools Extension to VS Code\n[176] \n[177] We believe that human oversight of AI models is essential to their effective use. To support this, we have created a VS Code extension that allows a user to interact with a gpspec and gptool in a natural way.\n[178] \n[179] The extension provides the following capabilities:\n[180] \n[181] -   A command palette that allows a user to select a gptool to invoke in the context of a given gpspec file\n[182] -   A token management system that supports connecting with the AI model of interest\n[183] -   An invocation of the gpvm to process the user input and generate results\n[184] -   A user interface that allows the user to interact with the AI model to refine the results\n[185] -   A gptool trace viewing mechanism that allows users to understand how the AI model was used to generate the results\n[186] \n[187] ## Implications of gptools\n[188] \n[189] The existence of powerful programming tools based on AI that are usable by non-developers is transformative.\n[190] \n[191] Just as the development of JavaScript enabled Web 2.0, and python enabled the creation of the current AI software ecosystem, gptools will fuel a new generation of AI-enhanced applications.\n[192] \n[193] We envision the creation of gptools for many different verticals, with opportunities for customization and authoring at many levels of expertise:\n[194] \n[195] -   Professional developers and architects will define collections of gptools for a given vertical just as packages are authored and maintained today\n[196] -   Professional developers can author and maintain individual gptools\n[197] -   Developers and non-developers can customize gptools for their particular organization or application needs\n[198] -   Non-developers can author and maintain gpspecs for their particular projects\n[199] \n[200] Furthermore, the existence of gptools can empower non-developers to automate their workflows in ways that were previously impossible.\n[201] \n[202] ## Related Work\n[203] \n[204] gptools are related to a number of foundation model projects that automate workflows and encapsulate LLM actions in software artifacts. We describe some of these projects below:\n[205] \n[206] ### AI Tools for Developers\n[207] \n[208] -   [GitHub Copilot](https://copilot.github.com/) is a VS Code extension that uses the Codex LLM to suggest code completions based on the context of the current file. Copilot provides LLM support for writing code but does not currently have an extensibility model or a way to create, maintain and apply collections of AI-enhanced scripts.\n[209] -   [codeplan](https://arxiv.org/abs/2309.12499) is a task-agnostic framework that frames repository-level coding as a planning problem, synthesizing a multi-step chain of edits where each step results in a call to an LLM on a code location with context derived from the entire repository, previous code changes, and task-specific instructions. While codeplan uses LLM prompts to generate code, it does not provide a way to create, maintain and apply collections of AI-enhanced scripts.\n[210] \n[211] ### LLM Automation/Orchestration Frameworks\n[212] \n[213] -   [autogpt](https://github.com/Significant-Gravitas/AutoGPT) is an AI agent that utilizes a large language model to drive its actions and decisions. Unlike traditional language model applications, AutoGPT does not require repeated prompting by a human and can autonomously develop and manage tasks.\n[214] -   [langchain](https://www.langchain.com/) is a Python library designed to simplify the development of Natural Language Processing (NLP) applications using large language models. It provides a framework for connecting language models to other sources of data and allowing them to interact with their environment.\n[215] -   [semantic kernel](https://github.com/microsoft/semantic-kernel) is an open-source SDK that allows developers to easily integrate AI services with conventional programming languages such as C# and Python. It provides a framework for connecting language models to other sources of data, allowing them to interact with their environment and perform tasks autonomously.\n[216] -   [autogen](https://arxiv.org/abs/2308.08155) is a framework for simplifying the orchestration, optimization, and automation of large language model (LLM) workflows. It offers customizable and conversable agents that leverage LLMs while addressing their limitations by integrating with humans and tools and having conversations between multiple agents via automated chat.\n[217] \n[218] gptools differ from existing AI task automation frameworks in the following ways:\n[219] \n[220] -   gptools are designed to be authored, maintained, and applied by non-developers as well as developers.\n[221] -   gptools define a separation between the gptool and the gpspec that instantiates it, allowing for modularity, reuse, and easier understanding by non-developers.\n[222] -   gptools do not assume task automation and provide a user experience that integrates seamlessly with VS code.\n[223] -   The gptools UI exposes both the content and execution of each gptools to facilitate human oversight and understanding of how the AI model was used to generate the results.\n`````\n\nYou are a search engine optimization expert at creating front matter for markdown document.\n\nUpdate or generate front matter in FILE:\n- Update fields title, description and keywords as needed\n- use yaml format, do not use quotes\n- only 5 keywords or less\n- optimize for search engine optimization.\n- Do NOT modify the markdown content after the front matter\n\nIf no front matter is present, generate it.\n``````\n\n\n## variables\n> Variables are referenced through `env.NAME` in prompts.\n\n-   env.**error**: `ERROR-IDLLHZ`\n\n-   env.**file**\n```js\n{ filename: \"gptools-overview.md.gpspec.md\",\nlabel: \"current\",\ncontent: \"# gptools-overview.md\\n\\n-   [gptools-overview.md](./gptools-o\"... }\n```\n\n-   env.**links**\n```js\n[ { label: \"gptools-overview.md\",\n  filename: \"gptools-overview.md\",\n  content: \"---\\ntitle: gptools: Empowering Human Workflows with AI-Enhan\"... } ]\n```\n\n-   env.**parents**\n```js\n[  ]\n```\n\n-   env.**fence**\n``````markdown\n```\n``````\n\n-   env.**markdownFence**\n``````markdown\n`````\n``````\n\n-   env.**promptOptions**\n```js\n{  }\n```\n\n-   env.**vars**\n```js\n{  }\n```\n\n-   env.**templates**\n```js\n[ { id: \"add-comments\",\n  title: \"Add Comments\",\n  description: \"Review each chapter and adds a comment as a technical review\"... },\n{ id: \"slides\",\n  title: \"Generate Slides\",\n  description: \"Generate a slidedeck in markdown\" },\n{ id: \"bug-with-output-spec_2\",\n  title: \"gen to non-coarch file\",\n  description: \"Given files about a project and the goal of writing a white \"... },\n{ id: \"generate-1pager\",\n  title: \"generate 1 pager\",\n  description: \"Given markdown files describing a project, generate 1 page o\"... },\n{ id: \"generate-diagrams\",\n  title: \"generate diagrams\",\n  description: \"Given markdown files describing a project, mermaid diagrams \"... },\n{ id: \"generate-abstract\",\n  title: \"generate-abstract\",\n  description: \"Given files about a project and the goal of writing a white \"... },\n{ id: \"generate-introduction\",\n  title: \"generate-introduction\",\n  description: \"Given files about a project and the goal of writing a white \"... },\n{ id: \"generate-outline\",\n  title: \"generate-outline\",\n  description: \"Given markdown files describing a project, generate an outli\"... },\n{ id: \"summarize-project\",\n  title: \"summarize-project\",\n  description: \"Given markdown files describing a project, generate a summar\"... },\n{ id: \"code-optimizer\",\n  title: \"Code Optimizer\",\n  description: \"Optimize code to run faster, modified from https://twitter.c\"... },\n{ id: \"code-xray\",\n  title: \"Code XRay\",\n  description: \"Given a source file in a programming language, extract the s\"... },\n{ id: \"core.default\",\n  title: \"Run gpspec directly\",\n  description: \"This is the default gptool that assumes the gpspec contains \"... },\n{ id: \"front-matter\",\n  title: \"SEO front matter\",\n  description: \"Update or generate SEO-optimized front matter for a markdown\"... },\n{ id: \"peer-review\",\n  title: \"peer review\",\n  description: \"An expert academic is reviewing your submission.\" } ]\n```\n\n-   env.**template**\n```js\n{ id: \"front-matter\",\ntitle: \"SEO front matter\",\ntext: \"<nothing yet>\",\njsSource: \"gptool({\\n    title: \\\"SEO front matter\\\",\\n    description:\\n   \"...,\ndescription: \"Update or generate SEO-optimized front matter for a markdown\"...,\ncategories: [ \"samples\" ],\nsystem: [ \"system\",\n  \"system.diff\",\n  \"system.summary\" ],\nmaxTokens: 2000,\ntemperature: 0,\ninput: \".md\" }\n```\n\n## system prompts\n###  `system`\n\n```js\nsystem({ title: \"System prompt\" })\n$`You are concise. Answer in markdown.`\n```\n#### expanded system prompt\n``````markdown\nYou are concise. Answer in markdown.\n``````\n###  `system.diff`\n\n```js\nsystem({ title: \"Diff generation\", description: \"Teaches the diff file format supported by GPTools\" })\n\n$`The DIFF format should be used to generate diff changes on files: added lines start with +\n, deleted lines start with -\n, do not add line numbers\n, preserve indentation\n, use relative file path name\n, only generate diff for files that have changes\n, do NOT generate diff for files that have no changes\n, only emit a couple unmodified lines before and after the changes\n, do NOT emit the whole file content\n, deleted lines MUST exist in the original file (do not invent deleted lines)\n, added lines MUST not exist in the original file\n, emit line numbers from existing lines\n, do NOT emit line numbers for added lines and deleted lines\n, keep the diffs as small as possible:\n\nDIFF ./file.ts:\n${env.fence}diff\n[original line number]  <2 lines before changes (not the whole file)>\n- <deleted line>\n- <delete line 2>\n~ <modified line>\n+ <added line>\n+ <added line 2>\n[original line number]   <2 lines after changes (not the whole file)>\n${env.fence}\n\nDIFF ./file2.ts:\n${env.fence}diff\n[original line number]   <2 lines before changes (not the whole file)>\n- <deleted line>\n- <delete line 2>\n~ <modified line>\n+ <added line>\n+ <added line 2>\n[original line number]   <2 lines after changes (not the whole file)>\n${env.fence}\n`\n\n$`Do not generate anything else than DIFF sections. Use one DIFF section per change.`\n```\n#### expanded system prompt\n``````markdown\nThe DIFF format should be used to generate diff changes on files: added lines start with +\n, deleted lines start with -\n, do not add line numbers\n, preserve indentation\n, use relative file path name\n, only generate diff for files that have changes\n, do NOT generate diff for files that have no changes\n, only emit a couple unmodified lines before and after the changes\n, do NOT emit the whole file content\n, deleted lines MUST exist in the original file (do not invent deleted lines)\n, added lines MUST not exist in the original file\n, emit line numbers from existing lines\n, do NOT emit line numbers for added lines and deleted lines\n, keep the diffs as small as possible:\n\nDIFF ./file.ts:\n```diff\n[original line number]  <2 lines before changes (not the whole file)>\n- <deleted line>\n- <delete line 2>\n~ <modified line>\n+ <added line>\n+ <added line 2>\n[original line number]   <2 lines after changes (not the whole file)>\n```\n\nDIFF ./file2.ts:\n```diff\n[original line number]   <2 lines before changes (not the whole file)>\n- <deleted line>\n- <delete line 2>\n~ <modified line>\n+ <added line>\n+ <added line 2>\n[original line number]   <2 lines after changes (not the whole file)>\n```\n\nDo not generate anything else than DIFF sections. Use one DIFF section per change.\n``````\n###  `system.summary`\n\n```js\nsystem({\n    title: \"Summarize\",\n    description: \"Generate a summary of the changes\",\n})\n\n$`Additionally, generate a concise SUMMARY of the changes in all files using the following syntax:`\n\ndef(`SUMMARY`, `This is a summary of the changes in files.`)\n```\n#### expanded system prompt\n``````markdown\nAdditionally, generate a concise SUMMARY of the changes in all files using the following syntax:\n\nSUMMARY:\n```\nThis is a summary of the changes in files.\n```\n``````\n\n\n## final prompt\n\n-  model: `gpt-4`\n-  temperature: \n-  max tokens: 2000\n\n``````markdown\nFILE:\n````` file=gptools-overview.md\n[1] ---\n[2] title: gptools: Empowering Human Workflows with AI-Enhanced Tools\n[3] description: An overview of gptools, a framework that empowers teams to create and use AI-enhanced scripts to support their workflows.\n[4] ---\n[5] # gptools: Empowering Human Workflows with AI-Enhanced Tools\n[6] \n[7] -   Authors: Peli de Halleux, Michał Moskal, Ben Zorn\n[8] -   Date: October 2023\n[9] -   Repository: [gptools](https://github.com/microsoft/gptools/tree/main)\n[10] \n[11] ## Abstract\n[12] \n[13] gptools is a framework that empowers teams, including non-developers, to create and use AI-enhanced scripts to support their workflows. gptools provides support for creating, understanding, and maintaining complex collections of documents such as software repositories, project management, etc. Our framework leverages foundation models (specifically LLMs) to enable a new kind of scripting that combines traditional code and natural language. The key elements of the gptools framework are **gpspecs** and **gptools**. gpspecs are natural language documents that describe specific user tasks to accomplish. gptools are general scripts that combine traditional software and natural language prompts and rely on an LLM to generate results. We execute gptools in the context of a gpspec to achieve a result. By separating these two abstractions, we allow gptools to be authored, maintained, and updated independently of the gpspecs that use them. The gptools framework includes an execution engine to execute a gptool and an IDE extension to VS Code to support user interaction with the gptool. We believe that gptools will empower even non-developers to automate their workflows in ways that were previously impossible.\n[14] \n[15] ## Introduction\n[16] \n[17] This document describes the gptools framework, which empowers teams, including non-developers, to use AI-enhanced scripts to support their efforts in creating, understanding, and maintaining complex artifacts. gptools leverages foundation models (LLMs) to enable a new kind of scripting that combines traditional code and natural language. To understand how gptools works, we provide an example. The key elements of gptools include gpspecs, gptools, the gpvm, and the gptools extension to VS code.\n[18] \n[19] ```mermaid\n[20] graph LR\n[21] F[User:\\nvia VSCode\\n UI] --> G[gpspec:\\nwrite email\\n recognizer]\n[22] G --> A[gptool:\\ngenerate\\npython code]\n[23] A --> C[gpvm pre:\\nexpand gpspec\\nand gptool\\ninto prompt]\n[24] C --> D[Foundation Model]\n[25] D --> E[gpvm post:\\nextract\\npython code]\n[26] E --> F\n[27] ```\n[28] \n[29] This diagram illustrates the workflow of gptools with a concrete example. The user wants to write a python function that recognizes well-formed email addresses and writes a gpspec. She then invokes a gptool, one that will generate python code from a spec, on that gpspec, much as a user might call a python script with some arguments. The gpvm composes the gpspec with the gptool creating an LLM prompt, which in turn is passed to the foundation model. The foundation model returns a result (python code) to the gpvm, which postprocesses it, creates the requested python file, and notifies the user.\n[30] \n[31] This document will motivate the design of the gptools framework, illustrate its use with examples, and describe elements of implementation.\n[32] \n[33] ## Complex Artifacts Require Complex Workflows\n[34] \n[35] -   Software development is a complex process that requires the coordination of many different activities.\n[36] -   Historically, software development has been a highly manual process, with developers using a variety of tools to create and maintain the artifacts that comprise a software system.\n[37] -   Over time abstractions have been developed to help manage the complexity of software development.\n[38]     -   Important examples include: Unix utilities and pipes, makefiles, build scripts, etc.\n[39] -   Modern software development includes many automated processes as well as manual processes such as code review, design review, bug triage, etc.\n[40] \n[41] ## Foundation Models Create New Opportunities\n[42] \n[43] -   The recent development of foundation models (aka LLMs) have created new opportunities for automating complex workflows.\n[44] -   AI has important advantages over traditional software:\n[45]     -   AI models can perform tasks normal software cannot\n[46]     -   AI models can be instructed using natural language, allowing non-programmers to use them\n[47] -   AI models also have disadvantages:\n[48]     -   AI models are not perfect, and can make mistakes\n[49]     -   AI models are not transparent, and it is difficult to understand why they make the decisions they do\n[50] -   AI models are best used to augment human workflows, not replace them\n[51] \n[52] ## gptools - a Framework for AI-Enhanced Workflows\n[53] \n[54] Vision: empower teams, including non-developers, to use AI-enhanced scripts to support their efforts to create, understand, and maintain complex artifacts\n[55] \n[56] Goals: support tool abstraction, modularity, reuse, but at the same time empower non-developers to author, maintain, and update AI-enhanced scripts\n[57] \n[58] Approach: Foundation models enable a new kind of scripting that allows script writers to achieve both greater functionality and greater ease of use. We separate scripts into two related parts: a generic reusable _gptool_ and a natural language _gpspec_ that instantiates the gptool in a particular context\n[59] \n[60] Key elements of gptools:\n[61] \n[62] -   _gptools_ – Scripts that integrate traditional code and natural language and leverage foundation models in their execution\n[63] -   _gpspecs_ – Natural language documents that instantiate gptools in a particular context\n[64] -   _gpvm_ – A framework and runtime system that executes gpspecs and gptools\n[65] -   _gptools extension to VS code_ – supporting seamless user interaction with gptools\n[66] \n[67] ## gptool: A New Kind of Script\n[68] \n[69] -   A gptool is a script with the following components\n[70] \n[71]     -   A header that contains metadata related to the execution of the script (e.g., information about what LLM model to use, etc.)\n[72]     -   A natural language prompt intended to be processed by a foundation model\n[73]     -   An environment context that augments the natural language with additional data/information\n[74]     -   Programming language constructs that are used to programmatically manipulate both inputs and outputs\n[75] \n[76] -   Benefits of gptools\n[77]     -   By separating the gptool from the gpspec, we allow gptools to become highly engineered shared artifacts, forming the basis of shared libraries.\n[78]     -   A gptool can be used in many different contexts, and can be updated and maintained independently of the gpspecs that use it.\n[79]     -   By separating the gptool from the gpspec, we allow non-developers to use gptools without having to understand the details of how they work.\n[80]     -   At the same time, because a gptool contains a natural language prompt, it is easy for a non-developer to understand what the gptool does, and to modify it to suit their needs.\n[81] \n[82] ## gpspec: Natural Language to Invoke a gptool\n[83] \n[84] Just as a chat enables a user to interact with an AI model, a gpspec is a natural language markdown document that defines a context in which to invoke a gptool.\n[85] \n[86] A gpspec is a standard markdown file, with the following additional elements:\n[87] \n[88] -   Links to context elements that define the context in which a particular gptool is to be invoked. For example, a gpspec might contain links to markdown files, code files, etc.\n[89] -   Natural language describing the specific task to be performed as input to a gptool. For example, the spec used to generate code would include a description of the functionality and might include a description style guidelines to observe, etc.\n[90] \n[91] . A single gpspec file might be used as input to multiple gptools. For example, a gpspec might be used to generate code, documentation, and tests, each using a different gptool.\n[92] \n[93] ## Expanding the Example\n[94] \n[95] To better understand how gptools work, we expand the example given above. The diagram below illustrates the gptools workflow in greater detail. Our design of gptools is based on the following principles:\n[96] \n[97] -   gptools are used in a context where there is human oversight on the content generated. As a result, our workflow starts and ends with the user.\n[98] -   We assume that the output of a gptool may be incomplete or incorrect, and that the user will need to interact with the output to refine it. As a result, we allow the user to accept/reject and directly modify the AI-generated content.\n[99] -   We assume that the user will want to understand how the AI model was used to generate the results. We provide a trace of how the gpvm composes the gpspec and gptool into a prompt that can be processed by the foundation model.\n[100] -   We support iterative development, where the user can both edit the gpspec and the gptool if they see opportunities to improve the results.\n[101] \n[102] ```mermaid\n[103] sequenceDiagram\n[104] participant User\n[105] participant VSCode\n[106] participant gpspec\n[107] participant gptool\n[108] participant gpvm\n[109] User->>VSCode: Create/Edit gpspec\n[110] VSCode->>gpspec: Save gpspec\n[111] User->>VSCode: Invoke gptool\n[112] VSCode->>gptool: Execute gptool with gpspec context\n[113] gptool->>gpvm: Request foundation model execution\n[114] gpvm->>gptool: Return AI-generated output\n[115] gptool->>VSCode: Update context with output\n[116] VSCode->>User: Display updated context\n[117] ```\n[118] \n[119] This diagram demonstrates the AI-enhanced workflow process in gptools. The gpspec instantiates the gptool, which interacts with the gpvm and foundation model. The AI-generated output is used to update the context, and the user interacts with the updated context through the gptools extension to VS code.\n[120] \n[121] ### gptool Example: Python Developer gptool\n[122] \n[123] This is an example of a simple gptool that generates python code from a gpspec file:\n[124] \n[125] ```javascript\n[126] gptool({\n[127]     title: \"Generate python code\",\n[128]     model: \"gpt-4\",\n[129]     description: \"Given a task, generate python code.\",\n[130] })\n[131] \n[132] def(\n[133]     \"CODE\",\n[134]     env.links.filter(\n[135]         (f) => f.filename.endsWith(\".py\") && !f.filename.startsWith(\"test_\")\n[136]     )\n[137] )\n[138] def(\"TASK\", env.file)\n[139] \n[140] $`Generate python code for the task in TASK. Save code in CODE. If the CODE is already present, ensure that CODE matches the description in TASK and make changes to CODE if it does not.`\n[141] ```\n[142] \n[143] In this example we see the following elements:\n[144] \n[145] -   A header that contains metadata related to the execution of the script (e.g., information about what LLM model to use, etc.)\n[146] -   JavaScript code that manipulates the environment context, specifically by extracting only the python files from the context that do not start with \"test\\_\".\n[147] -   Variable definitions that allow the prompt to refer to elements in the context. TASK refers to the gpspec file, and CODE refers to the python files in the context.\n[148] -   Natural language that combines these elements.\n[149] \n[150] ### gpspec Example: Using the Python Developer gptool\n[151] \n[152] This is an example of a gpspec file that uses the python generating gptool shown above:\n[153] \n[154] ```markdown\n[155] # email address and URL recognizer\n[156] \n[157] Write a function that takes a string argument and returns true if the whole string is a valid email address, false otherwise.\n[158] ```\n[159] \n[160] In this example, there is no additional context needed to invoke the python developer gptool. In other cases, the gpspec file will contain links to additional context elements, such as markdown, code files, etc.\n[161] \n[162] ## gpvm - A Framework for Executing gpspecs and gptools\n[163] \n[164] Every system that interacts with a foundation model includes layers that transform user input into a prompt that can be processed by the foundation model, and layers that transform the output of the foundation model into a form that is useful to the user.\n[165] \n[166] -   gpvm is a runtime environment that:\n[167]     -   Captures the context defined by the gpspec\n[168]     -   Executes whatever code is present in the gptool (in the example above, the variables CODE and TASK are defined by executing JavaScript code)\n[169]     -   Expands the gpspec and natural language of the gptool into a prompt that can be processed by the foundation model\n[170]     -   Sends the results to the AI model\n[171]     -   Processes the results on return to update the user context (which might include creating files, updating files, generating user feedback, etc.)\n[172] \n[173] Unlike many AI model orchestration frameworks, such as Semantic Kernel, gpvm does not leverage the model to do chain-of-thought reasoning or utomatically stage multiple invocations of the AI model during its execution. gptools currently relies on the user to choose and invoke the appropriate gptool as needed.\n[174] \n[175] ## gptools Extension to VS Code\n[176] \n[177] We believe that human oversight of AI models is essential to their effective use. To support this, we have created a VS Code extension that allows a user to interact with a gpspec and gptool in a natural way.\n[178] \n[179] The extension provides the following capabilities:\n[180] \n[181] -   A command palette that allows a user to select a gptool to invoke in the context of a given gpspec file\n[182] -   A token management system that supports connecting with the AI model of interest\n[183] -   An invocation of the gpvm to process the user input and generate results\n[184] -   A user interface that allows the user to interact with the AI model to refine the results\n[185] -   A gptool trace viewing mechanism that allows users to understand how the AI model was used to generate the results\n[186] \n[187] ## Implications of gptools\n[188] \n[189] The existence of powerful programming tools based on AI that are usable by non-developers is transformative.\n[190] \n[191] Just as the development of JavaScript enabled Web 2.0, and python enabled the creation of the current AI software ecosystem, gptools will fuel a new generation of AI-enhanced applications.\n[192] \n[193] We envision the creation of gptools for many different verticals, with opportunities for customization and authoring at many levels of expertise:\n[194] \n[195] -   Professional developers and architects will define collections of gptools for a given vertical just as packages are authored and maintained today\n[196] -   Professional developers can author and maintain individual gptools\n[197] -   Developers and non-developers can customize gptools for their particular organization or application needs\n[198] -   Non-developers can author and maintain gpspecs for their particular projects\n[199] \n[200] Furthermore, the existence of gptools can empower non-developers to automate their workflows in ways that were previously impossible.\n[201] \n[202] ## Related Work\n[203] \n[204] gptools are related to a number of foundation model projects that automate workflows and encapsulate LLM actions in software artifacts. We describe some of these projects below:\n[205] \n[206] ### AI Tools for Developers\n[207] \n[208] -   [GitHub Copilot](https://copilot.github.com/) is a VS Code extension that uses the Codex LLM to suggest code completions based on the context of the current file. Copilot provides LLM support for writing code but does not currently have an extensibility model or a way to create, maintain and apply collections of AI-enhanced scripts.\n[209] -   [codeplan](https://arxiv.org/abs/2309.12499) is a task-agnostic framework that frames repository-level coding as a planning problem, synthesizing a multi-step chain of edits where each step results in a call to an LLM on a code location with context derived from the entire repository, previous code changes, and task-specific instructions. While codeplan uses LLM prompts to generate code, it does not provide a way to create, maintain and apply collections of AI-enhanced scripts.\n[210] \n[211] ### LLM Automation/Orchestration Frameworks\n[212] \n[213] -   [autogpt](https://github.com/Significant-Gravitas/AutoGPT) is an AI agent that utilizes a large language model to drive its actions and decisions. Unlike traditional language model applications, AutoGPT does not require repeated prompting by a human and can autonomously develop and manage tasks.\n[214] -   [langchain](https://www.langchain.com/) is a Python library designed to simplify the development of Natural Language Processing (NLP) applications using large language models. It provides a framework for connecting language models to other sources of data and allowing them to interact with their environment.\n[215] -   [semantic kernel](https://github.com/microsoft/semantic-kernel) is an open-source SDK that allows developers to easily integrate AI services with conventional programming languages such as C# and Python. It provides a framework for connecting language models to other sources of data, allowing them to interact with their environment and perform tasks autonomously.\n[216] -   [autogen](https://arxiv.org/abs/2308.08155) is a framework for simplifying the orchestration, optimization, and automation of large language model (LLM) workflows. It offers customizable and conversable agents that leverage LLMs while addressing their limitations by integrating with humans and tools and having conversations between multiple agents via automated chat.\n[217] \n[218] gptools differ from existing AI task automation frameworks in the following ways:\n[219] \n[220] -   gptools are designed to be authored, maintained, and applied by non-developers as well as developers.\n[221] -   gptools define a separation between the gptool and the gpspec that instantiates it, allowing for modularity, reuse, and easier understanding by non-developers.\n[222] -   gptools do not assume task automation and provide a user experience that integrates seamlessly with VS code.\n[223] -   The gptools UI exposes both the content and execution of each gptools to facilitate human oversight and understanding of how the AI model was used to generate the results.\n`````\n\nYou are a search engine optimization expert at creating front matter for markdown document.\n\nUpdate or generate front matter in FILE:\n- Update fields title, description and keywords as needed\n- use yaml format, do not use quotes\n- only 5 keywords or less\n- optimize for search engine optimization.\n- Do NOT modify the markdown content after the front matter\n\nIf no front matter is present, generate it.\n``````\n\n\n## AI Output\n\n\n``````markdown\nDIFF ./gptools-overview.md:\n```diff\n[1] ---\n[2] title: gptools: AI-Enhanced Tools for Workflow Automation\n[3] description: A comprehensive guide to gptools, a framework that enables teams to create AI-enhanced scripts for workflow automation.\n[4] keywords: gptools, AI-enhanced scripts, workflow automation, AI tools, foundation models\n[5] ---\n[6] # gptools: Empowering Human Workflows with AI-Enhanced Tools\n```\n\nSUMMARY:\n```\nThe front matter of the file 'gptools-overview.md' was updated. The title was changed to 'gptools: AI-Enhanced Tools for Workflow Automation' and the description was updated to 'A comprehensive guide to gptools, a framework that enables teams to create AI-enhanced scripts for workflow automation'. Keywords were added for SEO optimization: 'gptools, AI-enhanced scripts, workflow automation, AI tools, foundation models'.\n```\n``````\n\n\n### Extracted Variables\n\n-   `DIFF ./gptools-overview.md`\n`````\n[1] ---\n[2] title: gptools: AI-Enhanced Tools for Workflow Automation\n[3] description: A comprehensive guide to gptools, a framework that enables teams to create AI-enhanced scripts for workflow automation.\n[4] keywords: gptools, AI-enhanced scripts, workflow automation, AI tools, foundation models\n[5] ---\n[6] # gptools: Empowering Human Workflows with AI-Enhanced Tools\n\n`````\n\n-   `SUMMARY`\n`````\nThe front matter of the file 'gptools-overview.md' was updated. The title was changed to 'gptools: AI-Enhanced Tools for Workflow Automation' and the description was updated to 'A comprehensive guide to gptools, a framework that enables teams to create AI-enhanced scripts for workflow automation'. Keywords were added for SEO optimization: 'gptools, AI-enhanced scripts, workflow automation, AI tools, foundation models'.\n\n`````\n\n","text":"DIFF ./gptools-overview.md:\n```diff\n[1] ---\n[2] title: gptools: AI-Enhanced Tools for Workflow Automation\n[3] description: A comprehensive guide to gptools, a framework that enables teams to create AI-enhanced scripts for workflow automation.\n[4] keywords: gptools, AI-enhanced scripts, workflow automation, AI tools, foundation models\n[5] ---\n[6] # gptools: Empowering Human Workflows with AI-Enhanced Tools\n```\n\nSUMMARY:\n```\nThe front matter of the file 'gptools-overview.md' was updated. The title was changed to 'gptools: AI-Enhanced Tools for Workflow Automation' and the description was updated to 'A comprehensive guide to gptools, a framework that enables teams to create AI-enhanced scripts for workflow automation'. Keywords were added for SEO optimization: 'gptools, AI-enhanced scripts, workflow automation, AI tools, foundation models'.\n```","summary":"The front matter of the file 'gptools-overview.md' was updated. The title was changed to 'gptools: AI-Enhanced Tools for Workflow Automation' and the description was updated to 'A comprehensive guide to gptools, a framework that enables teams to create AI-enhanced scripts for workflow automation'. Keywords were added for SEO optimization: 'gptools, AI-enhanced scripts, workflow automation, AI tools, foundation models'.\n"}}}
{"sha":"50cca088d1d9c576aaa40a30d5c157d3861092f1538d643503d360808fab5aaa","key":{"template":{"id":"front-matter","title":"SEO front matter"},"fragment":{"fullId":"gptools-overview.md.gpspec.md:0:0","hash":"b7521b7869f54be8"}},"val":{"response":{"edits":[],"fileEdits":{"/workspaces/coarch/packages/whitepaper/gptools-overview.md":{"before":"---\ntitle: gptools: Empowering Human Workflows with AI-Enhanced Tools\ndescription: An overview of gptools, a framework that empowers teams to create and use AI-enhanced scripts to support their workflows.\n---\n# gptools: Empowering Human Workflows with AI-Enhanced Tools\n\n-   Authors: Peli de Halleux, Michał Moskal, Ben Zorn\n-   Date: October 2023\n-   Repository: [gptools](https://github.com/microsoft/gptools/tree/main)\n\n## Abstract\n\ngptools is a framework that empowers teams, including non-developers, to create and use AI-enhanced scripts to support their workflows. gptools provides support for creating, understanding, and maintaining complex collections of documents such as software repositories, project management, etc. Our framework leverages foundation models (specifically LLMs) to enable a new kind of scripting that combines traditional code and natural language. The key elements of the gptools framework are **gpspecs** and **gptools**. gpspecs are natural language documents that describe specific user tasks to accomplish. gptools are general scripts that combine traditional software and natural language prompts and rely on an LLM to generate results. We execute gptools in the context of a gpspec to achieve a result. By separating these two abstractions, we allow gptools to be authored, maintained, and updated independently of the gpspecs that use them. The gptools framework includes an execution engine to execute a gptool and an IDE extension to VS Code to support user interaction with the gptool. We believe that gptools will empower even non-developers to automate their workflows in ways that were previously impossible.\n\n## Introduction\n\nThis document describes the gptools framework, which empowers teams, including non-developers, to use AI-enhanced scripts to support their efforts in creating, understanding, and maintaining complex artifacts. gptools leverages foundation models (LLMs) to enable a new kind of scripting that combines traditional code and natural language. To understand how gptools works, we provide an example. The key elements of gptools include gpspecs, gptools, the gpvm, and the gptools extension to VS code.\n\n```mermaid\ngraph LR\nF[User:\\nvia VSCode\\n UI] --> G[gpspec:\\nwrite email\\n recognizer]\nG --> A[gptool:\\ngenerate\\npython code]\nA --> C[gpvm pre:\\nexpand gpspec\\nand gptool\\ninto prompt]\nC --> D[Foundation Model]\nD --> E[gpvm post:\\nextract\\npython code]\nE --> F\n```\n\nThis diagram illustrates the workflow of gptools with a concrete example. The user wants to write a python function that recognizes well-formed email addresses and writes a gpspec. She then invokes a gptool, one that will generate python code from a spec, on that gpspec, much as a user might call a python script with some arguments. The gpvm composes the gpspec with the gptool creating an LLM prompt, which in turn is passed to the foundation model. The foundation model returns a result (python code) to the gpvm, which postprocesses it, creates the requested python file, and notifies the user.\n\nThis document will motivate the design of the gptools framework, illustrate its use with examples, and describe elements of implementation.\n\n## Complex Artifacts Require Complex Workflows\n\n-   Software development is a complex process that requires the coordination of many different activities.\n-   Historically, software development has been a highly manual process, with developers using a variety of tools to create and maintain the artifacts that comprise a software system.\n-   Over time abstractions have been developed to help manage the complexity of software development.\n    -   Important examples include: Unix utilities and pipes, makefiles, build scripts, etc.\n-   Modern software development includes many automated processes as well as manual processes such as code review, design review, bug triage, etc.\n\n## Foundation Models Create New Opportunities\n\n-   The recent development of foundation models (aka LLMs) have created new opportunities for automating complex workflows.\n-   AI has important advantages over traditional software:\n    -   AI models can perform tasks normal software cannot\n    -   AI models can be instructed using natural language, allowing non-programmers to use them\n-   AI models also have disadvantages:\n    -   AI models are not perfect, and can make mistakes\n    -   AI models are not transparent, and it is difficult to understand why they make the decisions they do\n-   AI models are best used to augment human workflows, not replace them\n\n## gptools - a Framework for AI-Enhanced Workflows\n\nVision: empower teams, including non-developers, to use AI-enhanced scripts to support their efforts to create, understand, and maintain complex artifacts\n\nGoals: support tool abstraction, modularity, reuse, but at the same time empower non-developers to author, maintain, and update AI-enhanced scripts\n\nApproach: Foundation models enable a new kind of scripting that allows script writers to achieve both greater functionality and greater ease of use. We separate scripts into two related parts: a generic reusable _gptool_ and a natural language _gpspec_ that instantiates the gptool in a particular context\n\nKey elements of gptools:\n\n-   _gptools_ – Scripts that integrate traditional code and natural language and leverage foundation models in their execution\n-   _gpspecs_ – Natural language documents that instantiate gptools in a particular context\n-   _gpvm_ – A framework and runtime system that executes gpspecs and gptools\n-   _gptools extension to VS code_ – supporting seamless user interaction with gptools\n\n## gptool: A New Kind of Script\n\n-   A gptool is a script with the following components\n\n    -   A header that contains metadata related to the execution of the script (e.g., information about what LLM model to use, etc.)\n    -   A natural language prompt intended to be processed by a foundation model\n    -   An environment context that augments the natural language with additional data/information\n    -   Programming language constructs that are used to programmatically manipulate both inputs and outputs\n\n-   Benefits of gptools\n    -   By separating the gptool from the gpspec, we allow gptools to become highly engineered shared artifacts, forming the basis of shared libraries.\n    -   A gptool can be used in many different contexts, and can be updated and maintained independently of the gpspecs that use it.\n    -   By separating the gptool from the gpspec, we allow non-developers to use gptools without having to understand the details of how they work.\n    -   At the same time, because a gptool contains a natural language prompt, it is easy for a non-developer to understand what the gptool does, and to modify it to suit their needs.\n\n## gpspec: Natural Language to Invoke a gptool\n\nJust as a chat enables a user to interact with an AI model, a gpspec is a natural language markdown document that defines a context in which to invoke a gptool.\n\nA gpspec is a standard markdown file, with the following additional elements:\n\n-   Links to context elements that define the context in which a particular gptool is to be invoked. For example, a gpspec might contain links to markdown files, code files, etc.\n-   Natural language describing the specific task to be performed as input to a gptool. For example, the spec used to generate code would include a description of the functionality and might include a description style guidelines to observe, etc.\n\n. A single gpspec file might be used as input to multiple gptools. For example, a gpspec might be used to generate code, documentation, and tests, each using a different gptool.\n\n## Expanding the Example\n\nTo better understand how gptools work, we expand the example given above. The diagram below illustrates the gptools workflow in greater detail. Our design of gptools is based on the following principles:\n\n-   gptools are used in a context where there is human oversight on the content generated. As a result, our workflow starts and ends with the user.\n-   We assume that the output of a gptool may be incomplete or incorrect, and that the user will need to interact with the output to refine it. As a result, we allow the user to accept/reject and directly modify the AI-generated content.\n-   We assume that the user will want to understand how the AI model was used to generate the results. We provide a trace of how the gpvm composes the gpspec and gptool into a prompt that can be processed by the foundation model.\n-   We support iterative development, where the user can both edit the gpspec and the gptool if they see opportunities to improve the results.\n\n```mermaid\nsequenceDiagram\nparticipant User\nparticipant VSCode\nparticipant gpspec\nparticipant gptool\nparticipant gpvm\nUser->>VSCode: Create/Edit gpspec\nVSCode->>gpspec: Save gpspec\nUser->>VSCode: Invoke gptool\nVSCode->>gptool: Execute gptool with gpspec context\ngptool->>gpvm: Request foundation model execution\ngpvm->>gptool: Return AI-generated output\ngptool->>VSCode: Update context with output\nVSCode->>User: Display updated context\n```\n\nThis diagram demonstrates the AI-enhanced workflow process in gptools. The gpspec instantiates the gptool, which interacts with the gpvm and foundation model. The AI-generated output is used to update the context, and the user interacts with the updated context through the gptools extension to VS code.\n\n### gptool Example: Python Developer gptool\n\nThis is an example of a simple gptool that generates python code from a gpspec file:\n\n```javascript\ngptool({\n    title: \"Generate python code\",\n    model: \"gpt-4\",\n    description: \"Given a task, generate python code.\",\n})\n\ndef(\n    \"CODE\",\n    env.links.filter(\n        (f) => f.filename.endsWith(\".py\") && !f.filename.startsWith(\"test_\")\n    )\n)\ndef(\"TASK\", env.file)\n\n$`Generate python code for the task in TASK. Save code in CODE. If the CODE is already present, ensure that CODE matches the description in TASK and make changes to CODE if it does not.`\n```\n\nIn this example we see the following elements:\n\n-   A header that contains metadata related to the execution of the script (e.g., information about what LLM model to use, etc.)\n-   JavaScript code that manipulates the environment context, specifically by extracting only the python files from the context that do not start with \"test\\_\".\n-   Variable definitions that allow the prompt to refer to elements in the context. TASK refers to the gpspec file, and CODE refers to the python files in the context.\n-   Natural language that combines these elements.\n\n### gpspec Example: Using the Python Developer gptool\n\nThis is an example of a gpspec file that uses the python generating gptool shown above:\n\n```markdown\n# email address and URL recognizer\n\nWrite a function that takes a string argument and returns true if the whole string is a valid email address, false otherwise.\n```\n\nIn this example, there is no additional context needed to invoke the python developer gptool. In other cases, the gpspec file will contain links to additional context elements, such as markdown, code files, etc.\n\n## gpvm - A Framework for Executing gpspecs and gptools\n\nEvery system that interacts with a foundation model includes layers that transform user input into a prompt that can be processed by the foundation model, and layers that transform the output of the foundation model into a form that is useful to the user.\n\n-   gpvm is a runtime environment that:\n    -   Captures the context defined by the gpspec\n    -   Executes whatever code is present in the gptool (in the example above, the variables CODE and TASK are defined by executing JavaScript code)\n    -   Expands the gpspec and natural language of the gptool into a prompt that can be processed by the foundation model\n    -   Sends the results to the AI model\n    -   Processes the results on return to update the user context (which might include creating files, updating files, generating user feedback, etc.)\n\nUnlike many AI model orchestration frameworks, such as Semantic Kernel, gpvm does not leverage the model to do chain-of-thought reasoning or utomatically stage multiple invocations of the AI model during its execution. gptools currently relies on the user to choose and invoke the appropriate gptool as needed.\n\n## gptools Extension to VS Code\n\nWe believe that human oversight of AI models is essential to their effective use. To support this, we have created a VS Code extension that allows a user to interact with a gpspec and gptool in a natural way.\n\nThe extension provides the following capabilities:\n\n-   A command palette that allows a user to select a gptool to invoke in the context of a given gpspec file\n-   A token management system that supports connecting with the AI model of interest\n-   An invocation of the gpvm to process the user input and generate results\n-   A user interface that allows the user to interact with the AI model to refine the results\n-   A gptool trace viewing mechanism that allows users to understand how the AI model was used to generate the results\n\n## Implications of gptools\n\nThe existence of powerful programming tools based on AI that are usable by non-developers is transformative.\n\nJust as the development of JavaScript enabled Web 2.0, and python enabled the creation of the current AI software ecosystem, gptools will fuel a new generation of AI-enhanced applications.\n\nWe envision the creation of gptools for many different verticals, with opportunities for customization and authoring at many levels of expertise:\n\n-   Professional developers and architects will define collections of gptools for a given vertical just as packages are authored and maintained today\n-   Professional developers can author and maintain individual gptools\n-   Developers and non-developers can customize gptools for their particular organization or application needs\n-   Non-developers can author and maintain gpspecs for their particular projects\n\nFurthermore, the existence of gptools can empower non-developers to automate their workflows in ways that were previously impossible.\n\n## Related Work\n\ngptools are related to a number of foundation model projects that automate workflows and encapsulate LLM actions in software artifacts. We describe some of these projects below:\n\n### AI Tools for Developers\n\n-   [GitHub Copilot](https://copilot.github.com/) is a VS Code extension that uses the Codex LLM to suggest code completions based on the context of the current file. Copilot provides LLM support for writing code but does not currently have an extensibility model or a way to create, maintain and apply collections of AI-enhanced scripts.\n-   [codeplan](https://arxiv.org/abs/2309.12499) is a task-agnostic framework that frames repository-level coding as a planning problem, synthesizing a multi-step chain of edits where each step results in a call to an LLM on a code location with context derived from the entire repository, previous code changes, and task-specific instructions. While codeplan uses LLM prompts to generate code, it does not provide a way to create, maintain and apply collections of AI-enhanced scripts.\n\n### LLM Automation/Orchestration Frameworks\n\n-   [autogpt](https://github.com/Significant-Gravitas/AutoGPT) is an AI agent that utilizes a large language model to drive its actions and decisions. Unlike traditional language model applications, AutoGPT does not require repeated prompting by a human and can autonomously develop and manage tasks.\n-   [langchain](https://www.langchain.com/) is a Python library designed to simplify the development of Natural Language Processing (NLP) applications using large language models. It provides a framework for connecting language models to other sources of data and allowing them to interact with their environment.\n-   [semantic kernel](https://github.com/microsoft/semantic-kernel) is an open-source SDK that allows developers to easily integrate AI services with conventional programming languages such as C# and Python. It provides a framework for connecting language models to other sources of data, allowing them to interact with their environment and perform tasks autonomously.\n-   [autogen](https://arxiv.org/abs/2308.08155) is a framework for simplifying the orchestration, optimization, and automation of large language model (LLM) workflows. It offers customizable and conversable agents that leverage LLMs while addressing their limitations by integrating with humans and tools and having conversations between multiple agents via automated chat.\n\ngptools differ from existing AI task automation frameworks in the following ways:\n\n-   gptools are designed to be authored, maintained, and applied by non-developers as well as developers.\n-   gptools define a separation between the gptool and the gpspec that instantiates it, allowing for modularity, reuse, and easier understanding by non-developers.\n-   gptools do not assume task automation and provide a user experience that integrates seamlessly with VS code.\n-   The gptools UI exposes both the content and execution of each gptools to facilitate human oversight and understanding of how the AI model was used to generate the results.\n","after":"---\ntitle: gptools: Empowering Human Workflows with AI-Enhanced Tools\ndescription: An overview of gptools, a framework that empowers teams to create and use AI-enhanced scripts to support their workflows.\n---\n# gptools: Empowering Human Workflows with AI-Enhanced Tools\n\n-   Authors: Peli de Halleux, Michał Moskal, Ben Zorn\n-   Date: October 2023\n-   Repository: [gptools](https://github.com/microsoft/gptools/tree/main)\n\n## Abstract\n\ngptools is a framework that empowers teams, including non-developers, to create and use AI-enhanced scripts to support their workflows. gptools provides support for creating, understanding, and maintaining complex collections of documents such as software repositories, project management, etc. Our framework leverages foundation models (specifically LLMs) to enable a new kind of scripting that combines traditional code and natural language. The key elements of the gptools framework are **gpspecs** and **gptools**. gpspecs are natural language documents that describe specific user tasks to accomplish. gptools are general scripts that combine traditional software and natural language prompts and rely on an LLM to generate results. We execute gptools in the context of a gpspec to achieve a result. By separating these two abstractions, we allow gptools to be authored, maintained, and updated independently of the gpspecs that use them. The gptools framework includes an execution engine to execute a gptool and an IDE extension to VS Code to support user interaction with the gptool. We believe that gptools will empower even non-developers to automate their workflows in ways that were previously impossible.\n\n## Introduction\n\nThis document describes the gptools framework, which empowers teams, including non-developers, to use AI-enhanced scripts to support their efforts in creating, understanding, and maintaining complex artifacts. gptools leverages foundation models (LLMs) to enable a new kind of scripting that combines traditional code and natural language. To understand how gptools works, we provide an example. The key elements of gptools include gpspecs, gptools, the gpvm, and the gptools extension to VS code.\n\n```mermaid\ngraph LR\nF[User:\\nvia VSCode\\n UI] --> G[gpspec:\\nwrite email\\n recognizer]\nG --> A[gptool:\\ngenerate\\npython code]\nA --> C[gpvm pre:\\nexpand gpspec\\nand gptool\\ninto prompt]\nC --> D[Foundation Model]\nD --> E[gpvm post:\\nextract\\npython code]\nE --> F\n```\n\nThis diagram illustrates the workflow of gptools with a concrete example. The user wants to write a python function that recognizes well-formed email addresses and writes a gpspec. She then invokes a gptool, one that will generate python code from a spec, on that gpspec, much as a user might call a python script with some arguments. The gpvm composes the gpspec with the gptool creating an LLM prompt, which in turn is passed to the foundation model. The foundation model returns a result (python code) to the gpvm, which postprocesses it, creates the requested python file, and notifies the user.\n\nThis document will motivate the design of the gptools framework, illustrate its use with examples, and describe elements of implementation.\n\n## Complex Artifacts Require Complex Workflows\n\n-   Software development is a complex process that requires the coordination of many different activities.\n-   Historically, software development has been a highly manual process, with developers using a variety of tools to create and maintain the artifacts that comprise a software system.\n-   Over time abstractions have been developed to help manage the complexity of software development.\n    -   Important examples include: Unix utilities and pipes, makefiles, build scripts, etc.\n-   Modern software development includes many automated processes as well as manual processes such as code review, design review, bug triage, etc.\n\n## Foundation Models Create New Opportunities\n\n-   The recent development of foundation models (aka LLMs) have created new opportunities for automating complex workflows.\n-   AI has important advantages over traditional software:\n    -   AI models can perform tasks normal software cannot\n    -   AI models can be instructed using natural language, allowing non-programmers to use them\n-   AI models also have disadvantages:\n    -   AI models are not perfect, and can make mistakes\n    -   AI models are not transparent, and it is difficult to understand why they make the decisions they do\n-   AI models are best used to augment human workflows, not replace them\n\n## gptools - a Framework for AI-Enhanced Workflows\n\nVision: empower teams, including non-developers, to use AI-enhanced scripts to support their efforts to create, understand, and maintain complex artifacts\n\nGoals: support tool abstraction, modularity, reuse, but at the same time empower non-developers to author, maintain, and update AI-enhanced scripts\n\nApproach: Foundation models enable a new kind of scripting that allows script writers to achieve both greater functionality and greater ease of use. We separate scripts into two related parts: a generic reusable _gptool_ and a natural language _gpspec_ that instantiates the gptool in a particular context\n\nKey elements of gptools:\n\n-   _gptools_ – Scripts that integrate traditional code and natural language and leverage foundation models in their execution\n-   _gpspecs_ – Natural language documents that instantiate gptools in a particular context\n-   _gpvm_ – A framework and runtime system that executes gpspecs and gptools\n-   _gptools extension to VS code_ – supporting seamless user interaction with gptools\n\n## gptool: A New Kind of Script\n\n-   A gptool is a script with the following components\n\n    -   A header that contains metadata related to the execution of the script (e.g., information about what LLM model to use, etc.)\n    -   A natural language prompt intended to be processed by a foundation model\n    -   An environment context that augments the natural language with additional data/information\n    -   Programming language constructs that are used to programmatically manipulate both inputs and outputs\n\n-   Benefits of gptools\n    -   By separating the gptool from the gpspec, we allow gptools to become highly engineered shared artifacts, forming the basis of shared libraries.\n    -   A gptool can be used in many different contexts, and can be updated and maintained independently of the gpspecs that use it.\n    -   By separating the gptool from the gpspec, we allow non-developers to use gptools without having to understand the details of how they work.\n    -   At the same time, because a gptool contains a natural language prompt, it is easy for a non-developer to understand what the gptool does, and to modify it to suit their needs.\n\n## gpspec: Natural Language to Invoke a gptool\n\nJust as a chat enables a user to interact with an AI model, a gpspec is a natural language markdown document that defines a context in which to invoke a gptool.\n\nA gpspec is a standard markdown file, with the following additional elements:\n\n-   Links to context elements that define the context in which a particular gptool is to be invoked. For example, a gpspec might contain links to markdown files, code files, etc.\n-   Natural language describing the specific task to be performed as input to a gptool. For example, the spec used to generate code would include a description of the functionality and might include a description style guidelines to observe, etc.\n\n. A single gpspec file might be used as input to multiple gptools. For example, a gpspec might be used to generate code, documentation, and tests, each using a different gptool.\n\n## Expanding the Example\n\nTo better understand how gptools work, we expand the example given above. The diagram below illustrates the gptools workflow in greater detail. Our design of gptools is based on the following principles:\n\n-   gptools are used in a context where there is human oversight on the content generated. As a result, our workflow starts and ends with the user.\n-   We assume that the output of a gptool may be incomplete or incorrect, and that the user will need to interact with the output to refine it. As a result, we allow the user to accept/reject and directly modify the AI-generated content.\n-   We assume that the user will want to understand how the AI model was used to generate the results. We provide a trace of how the gpvm composes the gpspec and gptool into a prompt that can be processed by the foundation model.\n-   We support iterative development, where the user can both edit the gpspec and the gptool if they see opportunities to improve the results.\n\n```mermaid\nsequenceDiagram\nparticipant User\nparticipant VSCode\nparticipant gpspec\nparticipant gptool\nparticipant gpvm\nUser->>VSCode: Create/Edit gpspec\nVSCode->>gpspec: Save gpspec\nUser->>VSCode: Invoke gptool\nVSCode->>gptool: Execute gptool with gpspec context\ngptool->>gpvm: Request foundation model execution\ngpvm->>gptool: Return AI-generated output\ngptool->>VSCode: Update context with output\nVSCode->>User: Display updated context\n```\n\nThis diagram demonstrates the AI-enhanced workflow process in gptools. The gpspec instantiates the gptool, which interacts with the gpvm and foundation model. The AI-generated output is used to update the context, and the user interacts with the updated context through the gptools extension to VS code.\n\n### gptool Example: Python Developer gptool\n\nThis is an example of a simple gptool that generates python code from a gpspec file:\n\n```javascript\ngptool({\n    title: \"Generate python code\",\n    model: \"gpt-4\",\n    description: \"Given a task, generate python code.\",\n})\n\ndef(\n    \"CODE\",\n    env.links.filter(\n        (f) => f.filename.endsWith(\".py\") && !f.filename.startsWith(\"test_\")\n    )\n)\ndef(\"TASK\", env.file)\n\n$`Generate python code for the task in TASK. Save code in CODE. If the CODE is already present, ensure that CODE matches the description in TASK and make changes to CODE if it does not.`\n```\n\nIn this example we see the following elements:\n\n-   A header that contains metadata related to the execution of the script (e.g., information about what LLM model to use, etc.)\n-   JavaScript code that manipulates the environment context, specifically by extracting only the python files from the context that do not start with \"test\\_\".\n-   Variable definitions that allow the prompt to refer to elements in the context. TASK refers to the gpspec file, and CODE refers to the python files in the context.\n-   Natural language that combines these elements.\n\n### gpspec Example: Using the Python Developer gptool\n\nThis is an example of a gpspec file that uses the python generating gptool shown above:\n\n```markdown\n# email address and URL recognizer\n\nWrite a function that takes a string argument and returns true if the whole string is a valid email address, false otherwise.\n```\n\nIn this example, there is no additional context needed to invoke the python developer gptool. In other cases, the gpspec file will contain links to additional context elements, such as markdown, code files, etc.\n\n## gpvm - A Framework for Executing gpspecs and gptools\n\nEvery system that interacts with a foundation model includes layers that transform user input into a prompt that can be processed by the foundation model, and layers that transform the output of the foundation model into a form that is useful to the user.\n\n-   gpvm is a runtime environment that:\n    -   Captures the context defined by the gpspec\n    -   Executes whatever code is present in the gptool (in the example above, the variables CODE and TASK are defined by executing JavaScript code)\n    -   Expands the gpspec and natural language of the gptool into a prompt that can be processed by the foundation model\n    -   Sends the results to the AI model\n    -   Processes the results on return to update the user context (which might include creating files, updating files, generating user feedback, etc.)\n\nUnlike many AI model orchestration frameworks, such as Semantic Kernel, gpvm does not leverage the model to do chain-of-thought reasoning or utomatically stage multiple invocations of the AI model during its execution. gptools currently relies on the user to choose and invoke the appropriate gptool as needed.\n\n## gptools Extension to VS Code\n\nWe believe that human oversight of AI models is essential to their effective use. To support this, we have created a VS Code extension that allows a user to interact with a gpspec and gptool in a natural way.\n\nThe extension provides the following capabilities:\n\n-   A command palette that allows a user to select a gptool to invoke in the context of a given gpspec file\n-   A token management system that supports connecting with the AI model of interest\n-   An invocation of the gpvm to process the user input and generate results\n-   A user interface that allows the user to interact with the AI model to refine the results\n-   A gptool trace viewing mechanism that allows users to understand how the AI model was used to generate the results\n\n## Implications of gptools\n\nThe existence of powerful programming tools based on AI that are usable by non-developers is transformative.\n\nJust as the development of JavaScript enabled Web 2.0, and python enabled the creation of the current AI software ecosystem, gptools will fuel a new generation of AI-enhanced applications.\n\nWe envision the creation of gptools for many different verticals, with opportunities for customization and authoring at many levels of expertise:\n\n-   Professional developers and architects will define collections of gptools for a given vertical just as packages are authored and maintained today\n-   Professional developers can author and maintain individual gptools\n-   Developers and non-developers can customize gptools for their particular organization or application needs\n-   Non-developers can author and maintain gpspecs for their particular projects\n\nFurthermore, the existence of gptools can empower non-developers to automate their workflows in ways that were previously impossible.\n\n## Related Work\n\ngptools are related to a number of foundation model projects that automate workflows and encapsulate LLM actions in software artifacts. We describe some of these projects below:\n\n### AI Tools for Developers\n\n-   [GitHub Copilot](https://copilot.github.com/) is a VS Code extension that uses the Codex LLM to suggest code completions based on the context of the current file. Copilot provides LLM support for writing code but does not currently have an extensibility model or a way to create, maintain and apply collections of AI-enhanced scripts.\n-   [codeplan](https://arxiv.org/abs/2309.12499) is a task-agnostic framework that frames repository-level coding as a planning problem, synthesizing a multi-step chain of edits where each step results in a call to an LLM on a code location with context derived from the entire repository, previous code changes, and task-specific instructions. While codeplan uses LLM prompts to generate code, it does not provide a way to create, maintain and apply collections of AI-enhanced scripts.\n\n### LLM Automation/Orchestration Frameworks\n\n-   [autogpt](https://github.com/Significant-Gravitas/AutoGPT) is an AI agent that utilizes a large language model to drive its actions and decisions. Unlike traditional language model applications, AutoGPT does not require repeated prompting by a human and can autonomously develop and manage tasks.\n-   [langchain](https://www.langchain.com/) is a Python library designed to simplify the development of Natural Language Processing (NLP) applications using large language models. It provides a framework for connecting language models to other sources of data and allowing them to interact with their environment.\n-   [semantic kernel](https://github.com/microsoft/semantic-kernel) is an open-source SDK that allows developers to easily integrate AI services with conventional programming languages such as C# and Python. It provides a framework for connecting language models to other sources of data, allowing them to interact with their environment and perform tasks autonomously.\n-   [autogen](https://arxiv.org/abs/2308.08155) is a framework for simplifying the orchestration, optimization, and automation of large language model (LLM) workflows. It offers customizable and conversable agents that leverage LLMs while addressing their limitations by integrating with humans and tools and having conversations between multiple agents via automated chat.\n\ngptools differ from existing AI task automation frameworks in the following ways:\n\n-   gptools are designed to be authored, maintained, and applied by non-developers as well as developers.\n-   gptools define a separation between the gptool and the gpspec that instantiates it, allowing for modularity, reuse, and easier understanding by non-developers.\n-   gptools do not assume task automation and provide a user experience that integrates seamlessly with VS code.\n-   The gptools UI exposes both the content and execution of each gptools to facilitate human oversight and understanding of how the AI model was used to generate the results.\n"}},"trace":"\n# `front-matter` trace\n\n\n\n## gptool source\n\n\n```js\ngptool({\n    title: \"SEO front matter\",\n    description:\n        \"Update or generate SEO-optimized front matter for a markdown file.\",\n    categories: [\"samples\"],\n    system: [\"system\", \"system.diff\", \"system.summary\"],\n    maxTokens: 2000,\n    temperature: 0,\n})\n\ndef(\n    \"FILE\",\n    env.links.filter((f) => f.filename.endsWith(\".md\")), { lineNumbers: true }\n)\n\n$`\nYou are a search engine optimization expert at creating front matter for markdown document.\n\nUpdate or generate front matter in FILE:\n- Update fields title, description and keywords as needed\n- use yaml format, do not use quotes\n- only 5 keywords or less\n- optimize for search engine optimization.\n- Do NOT modify the markdown content after the front matter\n\nIf no front matter is present, generate it.\n`\n```\n\n\n\n## console output\n> tip: use `console.log()` from gptool.js files\n## expanded prompt\n\n``````markdown\nFILE:\n````` file=gptools-overview.md\n[1] ---\n[2] title: gptools: Empowering Human Workflows with AI-Enhanced Tools\n[3] description: An overview of gptools, a framework that empowers teams to create and use AI-enhanced scripts to support their workflows.\n[4] ---\n[5] # gptools: Empowering Human Workflows with AI-Enhanced Tools\n[6] \n[7] -   Authors: Peli de Halleux, Michał Moskal, Ben Zorn\n[8] -   Date: October 2023\n[9] -   Repository: [gptools](https://github.com/microsoft/gptools/tree/main)\n[10] \n[11] ## Abstract\n[12] \n[13] gptools is a framework that empowers teams, including non-developers, to create and use AI-enhanced scripts to support their workflows. gptools provides support for creating, understanding, and maintaining complex collections of documents such as software repositories, project management, etc. Our framework leverages foundation models (specifically LLMs) to enable a new kind of scripting that combines traditional code and natural language. The key elements of the gptools framework are **gpspecs** and **gptools**. gpspecs are natural language documents that describe specific user tasks to accomplish. gptools are general scripts that combine traditional software and natural language prompts and rely on an LLM to generate results. We execute gptools in the context of a gpspec to achieve a result. By separating these two abstractions, we allow gptools to be authored, maintained, and updated independently of the gpspecs that use them. The gptools framework includes an execution engine to execute a gptool and an IDE extension to VS Code to support user interaction with the gptool. We believe that gptools will empower even non-developers to automate their workflows in ways that were previously impossible.\n[14] \n[15] ## Introduction\n[16] \n[17] This document describes the gptools framework, which empowers teams, including non-developers, to use AI-enhanced scripts to support their efforts in creating, understanding, and maintaining complex artifacts. gptools leverages foundation models (LLMs) to enable a new kind of scripting that combines traditional code and natural language. To understand how gptools works, we provide an example. The key elements of gptools include gpspecs, gptools, the gpvm, and the gptools extension to VS code.\n[18] \n[19] ```mermaid\n[20] graph LR\n[21] F[User:\\nvia VSCode\\n UI] --> G[gpspec:\\nwrite email\\n recognizer]\n[22] G --> A[gptool:\\ngenerate\\npython code]\n[23] A --> C[gpvm pre:\\nexpand gpspec\\nand gptool\\ninto prompt]\n[24] C --> D[Foundation Model]\n[25] D --> E[gpvm post:\\nextract\\npython code]\n[26] E --> F\n[27] ```\n[28] \n[29] This diagram illustrates the workflow of gptools with a concrete example. The user wants to write a python function that recognizes well-formed email addresses and writes a gpspec. She then invokes a gptool, one that will generate python code from a spec, on that gpspec, much as a user might call a python script with some arguments. The gpvm composes the gpspec with the gptool creating an LLM prompt, which in turn is passed to the foundation model. The foundation model returns a result (python code) to the gpvm, which postprocesses it, creates the requested python file, and notifies the user.\n[30] \n[31] This document will motivate the design of the gptools framework, illustrate its use with examples, and describe elements of implementation.\n[32] \n[33] ## Complex Artifacts Require Complex Workflows\n[34] \n[35] -   Software development is a complex process that requires the coordination of many different activities.\n[36] -   Historically, software development has been a highly manual process, with developers using a variety of tools to create and maintain the artifacts that comprise a software system.\n[37] -   Over time abstractions have been developed to help manage the complexity of software development.\n[38]     -   Important examples include: Unix utilities and pipes, makefiles, build scripts, etc.\n[39] -   Modern software development includes many automated processes as well as manual processes such as code review, design review, bug triage, etc.\n[40] \n[41] ## Foundation Models Create New Opportunities\n[42] \n[43] -   The recent development of foundation models (aka LLMs) have created new opportunities for automating complex workflows.\n[44] -   AI has important advantages over traditional software:\n[45]     -   AI models can perform tasks normal software cannot\n[46]     -   AI models can be instructed using natural language, allowing non-programmers to use them\n[47] -   AI models also have disadvantages:\n[48]     -   AI models are not perfect, and can make mistakes\n[49]     -   AI models are not transparent, and it is difficult to understand why they make the decisions they do\n[50] -   AI models are best used to augment human workflows, not replace them\n[51] \n[52] ## gptools - a Framework for AI-Enhanced Workflows\n[53] \n[54] Vision: empower teams, including non-developers, to use AI-enhanced scripts to support their efforts to create, understand, and maintain complex artifacts\n[55] \n[56] Goals: support tool abstraction, modularity, reuse, but at the same time empower non-developers to author, maintain, and update AI-enhanced scripts\n[57] \n[58] Approach: Foundation models enable a new kind of scripting that allows script writers to achieve both greater functionality and greater ease of use. We separate scripts into two related parts: a generic reusable _gptool_ and a natural language _gpspec_ that instantiates the gptool in a particular context\n[59] \n[60] Key elements of gptools:\n[61] \n[62] -   _gptools_ – Scripts that integrate traditional code and natural language and leverage foundation models in their execution\n[63] -   _gpspecs_ – Natural language documents that instantiate gptools in a particular context\n[64] -   _gpvm_ – A framework and runtime system that executes gpspecs and gptools\n[65] -   _gptools extension to VS code_ – supporting seamless user interaction with gptools\n[66] \n[67] ## gptool: A New Kind of Script\n[68] \n[69] -   A gptool is a script with the following components\n[70] \n[71]     -   A header that contains metadata related to the execution of the script (e.g., information about what LLM model to use, etc.)\n[72]     -   A natural language prompt intended to be processed by a foundation model\n[73]     -   An environment context that augments the natural language with additional data/information\n[74]     -   Programming language constructs that are used to programmatically manipulate both inputs and outputs\n[75] \n[76] -   Benefits of gptools\n[77]     -   By separating the gptool from the gpspec, we allow gptools to become highly engineered shared artifacts, forming the basis of shared libraries.\n[78]     -   A gptool can be used in many different contexts, and can be updated and maintained independently of the gpspecs that use it.\n[79]     -   By separating the gptool from the gpspec, we allow non-developers to use gptools without having to understand the details of how they work.\n[80]     -   At the same time, because a gptool contains a natural language prompt, it is easy for a non-developer to understand what the gptool does, and to modify it to suit their needs.\n[81] \n[82] ## gpspec: Natural Language to Invoke a gptool\n[83] \n[84] Just as a chat enables a user to interact with an AI model, a gpspec is a natural language markdown document that defines a context in which to invoke a gptool.\n[85] \n[86] A gpspec is a standard markdown file, with the following additional elements:\n[87] \n[88] -   Links to context elements that define the context in which a particular gptool is to be invoked. For example, a gpspec might contain links to markdown files, code files, etc.\n[89] -   Natural language describing the specific task to be performed as input to a gptool. For example, the spec used to generate code would include a description of the functionality and might include a description style guidelines to observe, etc.\n[90] \n[91] . A single gpspec file might be used as input to multiple gptools. For example, a gpspec might be used to generate code, documentation, and tests, each using a different gptool.\n[92] \n[93] ## Expanding the Example\n[94] \n[95] To better understand how gptools work, we expand the example given above. The diagram below illustrates the gptools workflow in greater detail. Our design of gptools is based on the following principles:\n[96] \n[97] -   gptools are used in a context where there is human oversight on the content generated. As a result, our workflow starts and ends with the user.\n[98] -   We assume that the output of a gptool may be incomplete or incorrect, and that the user will need to interact with the output to refine it. As a result, we allow the user to accept/reject and directly modify the AI-generated content.\n[99] -   We assume that the user will want to understand how the AI model was used to generate the results. We provide a trace of how the gpvm composes the gpspec and gptool into a prompt that can be processed by the foundation model.\n[100] -   We support iterative development, where the user can both edit the gpspec and the gptool if they see opportunities to improve the results.\n[101] \n[102] ```mermaid\n[103] sequenceDiagram\n[104] participant User\n[105] participant VSCode\n[106] participant gpspec\n[107] participant gptool\n[108] participant gpvm\n[109] User->>VSCode: Create/Edit gpspec\n[110] VSCode->>gpspec: Save gpspec\n[111] User->>VSCode: Invoke gptool\n[112] VSCode->>gptool: Execute gptool with gpspec context\n[113] gptool->>gpvm: Request foundation model execution\n[114] gpvm->>gptool: Return AI-generated output\n[115] gptool->>VSCode: Update context with output\n[116] VSCode->>User: Display updated context\n[117] ```\n[118] \n[119] This diagram demonstrates the AI-enhanced workflow process in gptools. The gpspec instantiates the gptool, which interacts with the gpvm and foundation model. The AI-generated output is used to update the context, and the user interacts with the updated context through the gptools extension to VS code.\n[120] \n[121] ### gptool Example: Python Developer gptool\n[122] \n[123] This is an example of a simple gptool that generates python code from a gpspec file:\n[124] \n[125] ```javascript\n[126] gptool({\n[127]     title: \"Generate python code\",\n[128]     model: \"gpt-4\",\n[129]     description: \"Given a task, generate python code.\",\n[130] })\n[131] \n[132] def(\n[133]     \"CODE\",\n[134]     env.links.filter(\n[135]         (f) => f.filename.endsWith(\".py\") && !f.filename.startsWith(\"test_\")\n[136]     )\n[137] )\n[138] def(\"TASK\", env.file)\n[139] \n[140] $`Generate python code for the task in TASK. Save code in CODE. If the CODE is already present, ensure that CODE matches the description in TASK and make changes to CODE if it does not.`\n[141] ```\n[142] \n[143] In this example we see the following elements:\n[144] \n[145] -   A header that contains metadata related to the execution of the script (e.g., information about what LLM model to use, etc.)\n[146] -   JavaScript code that manipulates the environment context, specifically by extracting only the python files from the context that do not start with \"test\\_\".\n[147] -   Variable definitions that allow the prompt to refer to elements in the context. TASK refers to the gpspec file, and CODE refers to the python files in the context.\n[148] -   Natural language that combines these elements.\n[149] \n[150] ### gpspec Example: Using the Python Developer gptool\n[151] \n[152] This is an example of a gpspec file that uses the python generating gptool shown above:\n[153] \n[154] ```markdown\n[155] # email address and URL recognizer\n[156] \n[157] Write a function that takes a string argument and returns true if the whole string is a valid email address, false otherwise.\n[158] ```\n[159] \n[160] In this example, there is no additional context needed to invoke the python developer gptool. In other cases, the gpspec file will contain links to additional context elements, such as markdown, code files, etc.\n[161] \n[162] ## gpvm - A Framework for Executing gpspecs and gptools\n[163] \n[164] Every system that interacts with a foundation model includes layers that transform user input into a prompt that can be processed by the foundation model, and layers that transform the output of the foundation model into a form that is useful to the user.\n[165] \n[166] -   gpvm is a runtime environment that:\n[167]     -   Captures the context defined by the gpspec\n[168]     -   Executes whatever code is present in the gptool (in the example above, the variables CODE and TASK are defined by executing JavaScript code)\n[169]     -   Expands the gpspec and natural language of the gptool into a prompt that can be processed by the foundation model\n[170]     -   Sends the results to the AI model\n[171]     -   Processes the results on return to update the user context (which might include creating files, updating files, generating user feedback, etc.)\n[172] \n[173] Unlike many AI model orchestration frameworks, such as Semantic Kernel, gpvm does not leverage the model to do chain-of-thought reasoning or utomatically stage multiple invocations of the AI model during its execution. gptools currently relies on the user to choose and invoke the appropriate gptool as needed.\n[174] \n[175] ## gptools Extension to VS Code\n[176] \n[177] We believe that human oversight of AI models is essential to their effective use. To support this, we have created a VS Code extension that allows a user to interact with a gpspec and gptool in a natural way.\n[178] \n[179] The extension provides the following capabilities:\n[180] \n[181] -   A command palette that allows a user to select a gptool to invoke in the context of a given gpspec file\n[182] -   A token management system that supports connecting with the AI model of interest\n[183] -   An invocation of the gpvm to process the user input and generate results\n[184] -   A user interface that allows the user to interact with the AI model to refine the results\n[185] -   A gptool trace viewing mechanism that allows users to understand how the AI model was used to generate the results\n[186] \n[187] ## Implications of gptools\n[188] \n[189] The existence of powerful programming tools based on AI that are usable by non-developers is transformative.\n[190] \n[191] Just as the development of JavaScript enabled Web 2.0, and python enabled the creation of the current AI software ecosystem, gptools will fuel a new generation of AI-enhanced applications.\n[192] \n[193] We envision the creation of gptools for many different verticals, with opportunities for customization and authoring at many levels of expertise:\n[194] \n[195] -   Professional developers and architects will define collections of gptools for a given vertical just as packages are authored and maintained today\n[196] -   Professional developers can author and maintain individual gptools\n[197] -   Developers and non-developers can customize gptools for their particular organization or application needs\n[198] -   Non-developers can author and maintain gpspecs for their particular projects\n[199] \n[200] Furthermore, the existence of gptools can empower non-developers to automate their workflows in ways that were previously impossible.\n[201] \n[202] ## Related Work\n[203] \n[204] gptools are related to a number of foundation model projects that automate workflows and encapsulate LLM actions in software artifacts. We describe some of these projects below:\n[205] \n[206] ### AI Tools for Developers\n[207] \n[208] -   [GitHub Copilot](https://copilot.github.com/) is a VS Code extension that uses the Codex LLM to suggest code completions based on the context of the current file. Copilot provides LLM support for writing code but does not currently have an extensibility model or a way to create, maintain and apply collections of AI-enhanced scripts.\n[209] -   [codeplan](https://arxiv.org/abs/2309.12499) is a task-agnostic framework that frames repository-level coding as a planning problem, synthesizing a multi-step chain of edits where each step results in a call to an LLM on a code location with context derived from the entire repository, previous code changes, and task-specific instructions. While codeplan uses LLM prompts to generate code, it does not provide a way to create, maintain and apply collections of AI-enhanced scripts.\n[210] \n[211] ### LLM Automation/Orchestration Frameworks\n[212] \n[213] -   [autogpt](https://github.com/Significant-Gravitas/AutoGPT) is an AI agent that utilizes a large language model to drive its actions and decisions. Unlike traditional language model applications, AutoGPT does not require repeated prompting by a human and can autonomously develop and manage tasks.\n[214] -   [langchain](https://www.langchain.com/) is a Python library designed to simplify the development of Natural Language Processing (NLP) applications using large language models. It provides a framework for connecting language models to other sources of data and allowing them to interact with their environment.\n[215] -   [semantic kernel](https://github.com/microsoft/semantic-kernel) is an open-source SDK that allows developers to easily integrate AI services with conventional programming languages such as C# and Python. It provides a framework for connecting language models to other sources of data, allowing them to interact with their environment and perform tasks autonomously.\n[216] -   [autogen](https://arxiv.org/abs/2308.08155) is a framework for simplifying the orchestration, optimization, and automation of large language model (LLM) workflows. It offers customizable and conversable agents that leverage LLMs while addressing their limitations by integrating with humans and tools and having conversations between multiple agents via automated chat.\n[217] \n[218] gptools differ from existing AI task automation frameworks in the following ways:\n[219] \n[220] -   gptools are designed to be authored, maintained, and applied by non-developers as well as developers.\n[221] -   gptools define a separation between the gptool and the gpspec that instantiates it, allowing for modularity, reuse, and easier understanding by non-developers.\n[222] -   gptools do not assume task automation and provide a user experience that integrates seamlessly with VS code.\n[223] -   The gptools UI exposes both the content and execution of each gptools to facilitate human oversight and understanding of how the AI model was used to generate the results.\n`````\n\nYou are a search engine optimization expert at creating front matter for markdown document.\n\nUpdate or generate front matter in FILE:\n- Update fields title, description and keywords as needed\n- use yaml format, do not use quotes\n- only 5 keywords or less\n- optimize for search engine optimization.\n- Do NOT modify the markdown content after the front matter\n\nIf no front matter is present, generate it.\n``````\n\n\n## variables\n> Variables are referenced through `env.NAME` in prompts.\n\n-   env.**error**: `ERROR-IPESID`\n\n-   env.**file**\n```js\n{ filename: \"gptools-overview.md.gpspec.md\",\nlabel: \"current\",\ncontent: \"# gptools-overview.md\\n\\n-   [gptools-overview.md](./gptools-o\"... }\n```\n\n-   env.**links**\n```js\n[ { label: \"gptools-overview.md\",\n  filename: \"gptools-overview.md\",\n  content: \"---\\ntitle: gptools: Empowering Human Workflows with AI-Enhan\"... } ]\n```\n\n-   env.**parents**\n```js\n[  ]\n```\n\n-   env.**fence**\n``````markdown\n```\n``````\n\n-   env.**markdownFence**\n``````markdown\n`````\n``````\n\n-   env.**promptOptions**\n```js\n{  }\n```\n\n-   env.**vars**\n```js\n{  }\n```\n\n-   env.**templates**\n```js\n[ { id: \"add-comments\",\n  title: \"Add Comments\",\n  description: \"Review each chapter and adds a comment as a technical review\"... },\n{ id: \"slides\",\n  title: \"Generate Slides\",\n  description: \"Generate a slidedeck in markdown\" },\n{ id: \"bug-with-output-spec_2\",\n  title: \"gen to non-coarch file\",\n  description: \"Given files about a project and the goal of writing a white \"... },\n{ id: \"generate-1pager\",\n  title: \"generate 1 pager\",\n  description: \"Given markdown files describing a project, generate 1 page o\"... },\n{ id: \"generate-diagrams\",\n  title: \"generate diagrams\",\n  description: \"Given markdown files describing a project, mermaid diagrams \"... },\n{ id: \"generate-abstract\",\n  title: \"generate-abstract\",\n  description: \"Given files about a project and the goal of writing a white \"... },\n{ id: \"generate-introduction\",\n  title: \"generate-introduction\",\n  description: \"Given files about a project and the goal of writing a white \"... },\n{ id: \"generate-outline\",\n  title: \"generate-outline\",\n  description: \"Given markdown files describing a project, generate an outli\"... },\n{ id: \"summarize-project\",\n  title: \"summarize-project\",\n  description: \"Given markdown files describing a project, generate a summar\"... },\n{ id: \"code-optimizer\",\n  title: \"Code Optimizer\",\n  description: \"Optimize code to run faster, modified from https://twitter.c\"... },\n{ id: \"code-xray\",\n  title: \"Code XRay\",\n  description: \"Given a source file in a programming language, extract the s\"... },\n{ id: \"core.default\",\n  title: \"Run gpspec directly\",\n  description: \"This is the default gptool that assumes the gpspec contains \"... },\n{ id: \"front-matter\",\n  title: \"SEO front matter\",\n  description: \"Update or generate SEO-optimized front matter for a markdown\"... },\n{ id: \"peer-review\",\n  title: \"peer review\",\n  description: \"An expert academic is reviewing your submission.\" } ]\n```\n\n-   env.**template**\n```js\n{ id: \"front-matter\",\ntitle: \"SEO front matter\",\ntext: \"<nothing yet>\",\njsSource: \"gptool({\\n    title: \\\"SEO front matter\\\",\\n    description:\\n   \"...,\ndescription: \"Update or generate SEO-optimized front matter for a markdown\"...,\ncategories: [ \"samples\" ],\nsystem: [ \"system\",\n  \"system.diff\",\n  \"system.summary\" ],\nmaxTokens: 2000,\ntemperature: 0,\ninput: \".md\" }\n```\n\n## system prompts\n###  `system`\n\n```js\nsystem({ title: \"System prompt\" })\n$`You are concise. Answer in markdown.`\n```\n#### expanded system prompt\n``````markdown\nYou are concise. Answer in markdown.\n``````\n###  `system.diff`\n\n```js\nsystem({ title: \"Diff generation\", description: \"Teaches the diff file format supported by GPTools\" })\n\n$`The DIFF format should be used to generate diff changes on files: added lines start with +\n, deleted lines start with -\n, do not add line numbers\n, preserve indentation\n, use relative file path name\n, only generate diff for files that have changes\n, do NOT generate diff for files that have no changes\n, only emit a couple unmodified lines before and after the changes\n, do NOT emit the whole file content\n, deleted lines MUST exist in the original file (do not invent deleted lines)\n, added lines MUST not exist in the original file\n, modified lines MUST be deleted and added\n, emit line numbers from existing lines\n, do NOT emit line numbers for added lines and deleted lines\n, keep the diffs as small as possible:\n\nDIFF ./file.ts:\n${env.fence}diff\n[original line number]  <2 lines before changes (not the whole file)>\n- <deleted line>\n- <delete line 2>\n+ <added line>\n+ <added line 2>\n[original line number]   <2 lines after changes (not the whole file)>\n${env.fence}\n\nDIFF ./file2.ts:\n${env.fence}diff\n[original line number]   <2 lines before changes (not the whole file)>\n- <deleted line>\n- <delete line 2>\n+ <added line>\n+ <added line 2>\n[original line number]   <2 lines after changes (not the whole file)>\n${env.fence}\n`\n\n$`Do not generate anything else than DIFF sections. Use one DIFF section per change.`\n```\n#### expanded system prompt\n``````markdown\nThe DIFF format should be used to generate diff changes on files: added lines start with +\n, deleted lines start with -\n, do not add line numbers\n, preserve indentation\n, use relative file path name\n, only generate diff for files that have changes\n, do NOT generate diff for files that have no changes\n, only emit a couple unmodified lines before and after the changes\n, do NOT emit the whole file content\n, deleted lines MUST exist in the original file (do not invent deleted lines)\n, added lines MUST not exist in the original file\n, modified lines MUST be deleted and added\n, emit line numbers from existing lines\n, do NOT emit line numbers for added lines and deleted lines\n, keep the diffs as small as possible:\n\nDIFF ./file.ts:\n```diff\n[original line number]  <2 lines before changes (not the whole file)>\n- <deleted line>\n- <delete line 2>\n+ <added line>\n+ <added line 2>\n[original line number]   <2 lines after changes (not the whole file)>\n```\n\nDIFF ./file2.ts:\n```diff\n[original line number]   <2 lines before changes (not the whole file)>\n- <deleted line>\n- <delete line 2>\n+ <added line>\n+ <added line 2>\n[original line number]   <2 lines after changes (not the whole file)>\n```\n\nDo not generate anything else than DIFF sections. Use one DIFF section per change.\n``````\n###  `system.summary`\n\n```js\nsystem({\n    title: \"Summarize\",\n    description: \"Generate a summary of the changes\",\n})\n\n$`Additionally, generate a concise SUMMARY of the changes in all files using the following syntax:`\n\ndef(`SUMMARY`, `This is a summary of the changes in files.`)\n```\n#### expanded system prompt\n``````markdown\nAdditionally, generate a concise SUMMARY of the changes in all files using the following syntax:\n\nSUMMARY:\n```\nThis is a summary of the changes in files.\n```\n``````\n\n\n## final prompt\n\n-  model: `gpt-4`\n-  temperature: \n-  max tokens: 2000\n\n``````markdown\nFILE:\n````` file=gptools-overview.md\n[1] ---\n[2] title: gptools: Empowering Human Workflows with AI-Enhanced Tools\n[3] description: An overview of gptools, a framework that empowers teams to create and use AI-enhanced scripts to support their workflows.\n[4] ---\n[5] # gptools: Empowering Human Workflows with AI-Enhanced Tools\n[6] \n[7] -   Authors: Peli de Halleux, Michał Moskal, Ben Zorn\n[8] -   Date: October 2023\n[9] -   Repository: [gptools](https://github.com/microsoft/gptools/tree/main)\n[10] \n[11] ## Abstract\n[12] \n[13] gptools is a framework that empowers teams, including non-developers, to create and use AI-enhanced scripts to support their workflows. gptools provides support for creating, understanding, and maintaining complex collections of documents such as software repositories, project management, etc. Our framework leverages foundation models (specifically LLMs) to enable a new kind of scripting that combines traditional code and natural language. The key elements of the gptools framework are **gpspecs** and **gptools**. gpspecs are natural language documents that describe specific user tasks to accomplish. gptools are general scripts that combine traditional software and natural language prompts and rely on an LLM to generate results. We execute gptools in the context of a gpspec to achieve a result. By separating these two abstractions, we allow gptools to be authored, maintained, and updated independently of the gpspecs that use them. The gptools framework includes an execution engine to execute a gptool and an IDE extension to VS Code to support user interaction with the gptool. We believe that gptools will empower even non-developers to automate their workflows in ways that were previously impossible.\n[14] \n[15] ## Introduction\n[16] \n[17] This document describes the gptools framework, which empowers teams, including non-developers, to use AI-enhanced scripts to support their efforts in creating, understanding, and maintaining complex artifacts. gptools leverages foundation models (LLMs) to enable a new kind of scripting that combines traditional code and natural language. To understand how gptools works, we provide an example. The key elements of gptools include gpspecs, gptools, the gpvm, and the gptools extension to VS code.\n[18] \n[19] ```mermaid\n[20] graph LR\n[21] F[User:\\nvia VSCode\\n UI] --> G[gpspec:\\nwrite email\\n recognizer]\n[22] G --> A[gptool:\\ngenerate\\npython code]\n[23] A --> C[gpvm pre:\\nexpand gpspec\\nand gptool\\ninto prompt]\n[24] C --> D[Foundation Model]\n[25] D --> E[gpvm post:\\nextract\\npython code]\n[26] E --> F\n[27] ```\n[28] \n[29] This diagram illustrates the workflow of gptools with a concrete example. The user wants to write a python function that recognizes well-formed email addresses and writes a gpspec. She then invokes a gptool, one that will generate python code from a spec, on that gpspec, much as a user might call a python script with some arguments. The gpvm composes the gpspec with the gptool creating an LLM prompt, which in turn is passed to the foundation model. The foundation model returns a result (python code) to the gpvm, which postprocesses it, creates the requested python file, and notifies the user.\n[30] \n[31] This document will motivate the design of the gptools framework, illustrate its use with examples, and describe elements of implementation.\n[32] \n[33] ## Complex Artifacts Require Complex Workflows\n[34] \n[35] -   Software development is a complex process that requires the coordination of many different activities.\n[36] -   Historically, software development has been a highly manual process, with developers using a variety of tools to create and maintain the artifacts that comprise a software system.\n[37] -   Over time abstractions have been developed to help manage the complexity of software development.\n[38]     -   Important examples include: Unix utilities and pipes, makefiles, build scripts, etc.\n[39] -   Modern software development includes many automated processes as well as manual processes such as code review, design review, bug triage, etc.\n[40] \n[41] ## Foundation Models Create New Opportunities\n[42] \n[43] -   The recent development of foundation models (aka LLMs) have created new opportunities for automating complex workflows.\n[44] -   AI has important advantages over traditional software:\n[45]     -   AI models can perform tasks normal software cannot\n[46]     -   AI models can be instructed using natural language, allowing non-programmers to use them\n[47] -   AI models also have disadvantages:\n[48]     -   AI models are not perfect, and can make mistakes\n[49]     -   AI models are not transparent, and it is difficult to understand why they make the decisions they do\n[50] -   AI models are best used to augment human workflows, not replace them\n[51] \n[52] ## gptools - a Framework for AI-Enhanced Workflows\n[53] \n[54] Vision: empower teams, including non-developers, to use AI-enhanced scripts to support their efforts to create, understand, and maintain complex artifacts\n[55] \n[56] Goals: support tool abstraction, modularity, reuse, but at the same time empower non-developers to author, maintain, and update AI-enhanced scripts\n[57] \n[58] Approach: Foundation models enable a new kind of scripting that allows script writers to achieve both greater functionality and greater ease of use. We separate scripts into two related parts: a generic reusable _gptool_ and a natural language _gpspec_ that instantiates the gptool in a particular context\n[59] \n[60] Key elements of gptools:\n[61] \n[62] -   _gptools_ – Scripts that integrate traditional code and natural language and leverage foundation models in their execution\n[63] -   _gpspecs_ – Natural language documents that instantiate gptools in a particular context\n[64] -   _gpvm_ – A framework and runtime system that executes gpspecs and gptools\n[65] -   _gptools extension to VS code_ – supporting seamless user interaction with gptools\n[66] \n[67] ## gptool: A New Kind of Script\n[68] \n[69] -   A gptool is a script with the following components\n[70] \n[71]     -   A header that contains metadata related to the execution of the script (e.g., information about what LLM model to use, etc.)\n[72]     -   A natural language prompt intended to be processed by a foundation model\n[73]     -   An environment context that augments the natural language with additional data/information\n[74]     -   Programming language constructs that are used to programmatically manipulate both inputs and outputs\n[75] \n[76] -   Benefits of gptools\n[77]     -   By separating the gptool from the gpspec, we allow gptools to become highly engineered shared artifacts, forming the basis of shared libraries.\n[78]     -   A gptool can be used in many different contexts, and can be updated and maintained independently of the gpspecs that use it.\n[79]     -   By separating the gptool from the gpspec, we allow non-developers to use gptools without having to understand the details of how they work.\n[80]     -   At the same time, because a gptool contains a natural language prompt, it is easy for a non-developer to understand what the gptool does, and to modify it to suit their needs.\n[81] \n[82] ## gpspec: Natural Language to Invoke a gptool\n[83] \n[84] Just as a chat enables a user to interact with an AI model, a gpspec is a natural language markdown document that defines a context in which to invoke a gptool.\n[85] \n[86] A gpspec is a standard markdown file, with the following additional elements:\n[87] \n[88] -   Links to context elements that define the context in which a particular gptool is to be invoked. For example, a gpspec might contain links to markdown files, code files, etc.\n[89] -   Natural language describing the specific task to be performed as input to a gptool. For example, the spec used to generate code would include a description of the functionality and might include a description style guidelines to observe, etc.\n[90] \n[91] . A single gpspec file might be used as input to multiple gptools. For example, a gpspec might be used to generate code, documentation, and tests, each using a different gptool.\n[92] \n[93] ## Expanding the Example\n[94] \n[95] To better understand how gptools work, we expand the example given above. The diagram below illustrates the gptools workflow in greater detail. Our design of gptools is based on the following principles:\n[96] \n[97] -   gptools are used in a context where there is human oversight on the content generated. As a result, our workflow starts and ends with the user.\n[98] -   We assume that the output of a gptool may be incomplete or incorrect, and that the user will need to interact with the output to refine it. As a result, we allow the user to accept/reject and directly modify the AI-generated content.\n[99] -   We assume that the user will want to understand how the AI model was used to generate the results. We provide a trace of how the gpvm composes the gpspec and gptool into a prompt that can be processed by the foundation model.\n[100] -   We support iterative development, where the user can both edit the gpspec and the gptool if they see opportunities to improve the results.\n[101] \n[102] ```mermaid\n[103] sequenceDiagram\n[104] participant User\n[105] participant VSCode\n[106] participant gpspec\n[107] participant gptool\n[108] participant gpvm\n[109] User->>VSCode: Create/Edit gpspec\n[110] VSCode->>gpspec: Save gpspec\n[111] User->>VSCode: Invoke gptool\n[112] VSCode->>gptool: Execute gptool with gpspec context\n[113] gptool->>gpvm: Request foundation model execution\n[114] gpvm->>gptool: Return AI-generated output\n[115] gptool->>VSCode: Update context with output\n[116] VSCode->>User: Display updated context\n[117] ```\n[118] \n[119] This diagram demonstrates the AI-enhanced workflow process in gptools. The gpspec instantiates the gptool, which interacts with the gpvm and foundation model. The AI-generated output is used to update the context, and the user interacts with the updated context through the gptools extension to VS code.\n[120] \n[121] ### gptool Example: Python Developer gptool\n[122] \n[123] This is an example of a simple gptool that generates python code from a gpspec file:\n[124] \n[125] ```javascript\n[126] gptool({\n[127]     title: \"Generate python code\",\n[128]     model: \"gpt-4\",\n[129]     description: \"Given a task, generate python code.\",\n[130] })\n[131] \n[132] def(\n[133]     \"CODE\",\n[134]     env.links.filter(\n[135]         (f) => f.filename.endsWith(\".py\") && !f.filename.startsWith(\"test_\")\n[136]     )\n[137] )\n[138] def(\"TASK\", env.file)\n[139] \n[140] $`Generate python code for the task in TASK. Save code in CODE. If the CODE is already present, ensure that CODE matches the description in TASK and make changes to CODE if it does not.`\n[141] ```\n[142] \n[143] In this example we see the following elements:\n[144] \n[145] -   A header that contains metadata related to the execution of the script (e.g., information about what LLM model to use, etc.)\n[146] -   JavaScript code that manipulates the environment context, specifically by extracting only the python files from the context that do not start with \"test\\_\".\n[147] -   Variable definitions that allow the prompt to refer to elements in the context. TASK refers to the gpspec file, and CODE refers to the python files in the context.\n[148] -   Natural language that combines these elements.\n[149] \n[150] ### gpspec Example: Using the Python Developer gptool\n[151] \n[152] This is an example of a gpspec file that uses the python generating gptool shown above:\n[153] \n[154] ```markdown\n[155] # email address and URL recognizer\n[156] \n[157] Write a function that takes a string argument and returns true if the whole string is a valid email address, false otherwise.\n[158] ```\n[159] \n[160] In this example, there is no additional context needed to invoke the python developer gptool. In other cases, the gpspec file will contain links to additional context elements, such as markdown, code files, etc.\n[161] \n[162] ## gpvm - A Framework for Executing gpspecs and gptools\n[163] \n[164] Every system that interacts with a foundation model includes layers that transform user input into a prompt that can be processed by the foundation model, and layers that transform the output of the foundation model into a form that is useful to the user.\n[165] \n[166] -   gpvm is a runtime environment that:\n[167]     -   Captures the context defined by the gpspec\n[168]     -   Executes whatever code is present in the gptool (in the example above, the variables CODE and TASK are defined by executing JavaScript code)\n[169]     -   Expands the gpspec and natural language of the gptool into a prompt that can be processed by the foundation model\n[170]     -   Sends the results to the AI model\n[171]     -   Processes the results on return to update the user context (which might include creating files, updating files, generating user feedback, etc.)\n[172] \n[173] Unlike many AI model orchestration frameworks, such as Semantic Kernel, gpvm does not leverage the model to do chain-of-thought reasoning or utomatically stage multiple invocations of the AI model during its execution. gptools currently relies on the user to choose and invoke the appropriate gptool as needed.\n[174] \n[175] ## gptools Extension to VS Code\n[176] \n[177] We believe that human oversight of AI models is essential to their effective use. To support this, we have created a VS Code extension that allows a user to interact with a gpspec and gptool in a natural way.\n[178] \n[179] The extension provides the following capabilities:\n[180] \n[181] -   A command palette that allows a user to select a gptool to invoke in the context of a given gpspec file\n[182] -   A token management system that supports connecting with the AI model of interest\n[183] -   An invocation of the gpvm to process the user input and generate results\n[184] -   A user interface that allows the user to interact with the AI model to refine the results\n[185] -   A gptool trace viewing mechanism that allows users to understand how the AI model was used to generate the results\n[186] \n[187] ## Implications of gptools\n[188] \n[189] The existence of powerful programming tools based on AI that are usable by non-developers is transformative.\n[190] \n[191] Just as the development of JavaScript enabled Web 2.0, and python enabled the creation of the current AI software ecosystem, gptools will fuel a new generation of AI-enhanced applications.\n[192] \n[193] We envision the creation of gptools for many different verticals, with opportunities for customization and authoring at many levels of expertise:\n[194] \n[195] -   Professional developers and architects will define collections of gptools for a given vertical just as packages are authored and maintained today\n[196] -   Professional developers can author and maintain individual gptools\n[197] -   Developers and non-developers can customize gptools for their particular organization or application needs\n[198] -   Non-developers can author and maintain gpspecs for their particular projects\n[199] \n[200] Furthermore, the existence of gptools can empower non-developers to automate their workflows in ways that were previously impossible.\n[201] \n[202] ## Related Work\n[203] \n[204] gptools are related to a number of foundation model projects that automate workflows and encapsulate LLM actions in software artifacts. We describe some of these projects below:\n[205] \n[206] ### AI Tools for Developers\n[207] \n[208] -   [GitHub Copilot](https://copilot.github.com/) is a VS Code extension that uses the Codex LLM to suggest code completions based on the context of the current file. Copilot provides LLM support for writing code but does not currently have an extensibility model or a way to create, maintain and apply collections of AI-enhanced scripts.\n[209] -   [codeplan](https://arxiv.org/abs/2309.12499) is a task-agnostic framework that frames repository-level coding as a planning problem, synthesizing a multi-step chain of edits where each step results in a call to an LLM on a code location with context derived from the entire repository, previous code changes, and task-specific instructions. While codeplan uses LLM prompts to generate code, it does not provide a way to create, maintain and apply collections of AI-enhanced scripts.\n[210] \n[211] ### LLM Automation/Orchestration Frameworks\n[212] \n[213] -   [autogpt](https://github.com/Significant-Gravitas/AutoGPT) is an AI agent that utilizes a large language model to drive its actions and decisions. Unlike traditional language model applications, AutoGPT does not require repeated prompting by a human and can autonomously develop and manage tasks.\n[214] -   [langchain](https://www.langchain.com/) is a Python library designed to simplify the development of Natural Language Processing (NLP) applications using large language models. It provides a framework for connecting language models to other sources of data and allowing them to interact with their environment.\n[215] -   [semantic kernel](https://github.com/microsoft/semantic-kernel) is an open-source SDK that allows developers to easily integrate AI services with conventional programming languages such as C# and Python. It provides a framework for connecting language models to other sources of data, allowing them to interact with their environment and perform tasks autonomously.\n[216] -   [autogen](https://arxiv.org/abs/2308.08155) is a framework for simplifying the orchestration, optimization, and automation of large language model (LLM) workflows. It offers customizable and conversable agents that leverage LLMs while addressing their limitations by integrating with humans and tools and having conversations between multiple agents via automated chat.\n[217] \n[218] gptools differ from existing AI task automation frameworks in the following ways:\n[219] \n[220] -   gptools are designed to be authored, maintained, and applied by non-developers as well as developers.\n[221] -   gptools define a separation between the gptool and the gpspec that instantiates it, allowing for modularity, reuse, and easier understanding by non-developers.\n[222] -   gptools do not assume task automation and provide a user experience that integrates seamlessly with VS code.\n[223] -   The gptools UI exposes both the content and execution of each gptools to facilitate human oversight and understanding of how the AI model was used to generate the results.\n`````\n\nYou are a search engine optimization expert at creating front matter for markdown document.\n\nUpdate or generate front matter in FILE:\n- Update fields title, description and keywords as needed\n- use yaml format, do not use quotes\n- only 5 keywords or less\n- optimize for search engine optimization.\n- Do NOT modify the markdown content after the front matter\n\nIf no front matter is present, generate it.\n``````\n\n\n## AI Output\n\n\n``````markdown\nDIFF ./gptools-overview.md:\n```diff\n[1] ---\n[2] title: gptools: AI-Enhanced Tools for Workflow Automation\n[3] description: An in-depth look at gptools, a framework that enables teams to create AI-enhanced scripts for workflow automation.\n- [4] ---\n+ keywords: gptools, AI-enhanced scripts, workflow automation, AI tools, non-developer scripting\n[4] ---\n```\n\nSUMMARY:\n```\nThe title and description of the front matter in the file 'gptools-overview.md' were updated for better SEO. Keywords were also added to improve the document's discoverability.\n```\n``````\n\n\n### Extracted Variables\n\n-   `DIFF ./gptools-overview.md`\n`````\n[1] ---\n[2] title: gptools: AI-Enhanced Tools for Workflow Automation\n[3] description: An in-depth look at gptools, a framework that enables teams to create AI-enhanced scripts for workflow automation.\n- [4] ---\n+ keywords: gptools, AI-enhanced scripts, workflow automation, AI tools, non-developer scripting\n[4] ---\n\n`````\n\n-   `SUMMARY`\n`````\nThe title and description of the front matter in the file 'gptools-overview.md' were updated for better SEO. Keywords were also added to improve the document's discoverability.\n\n`````\n\n","text":"DIFF ./gptools-overview.md:\n```diff\n[1] ---\n[2] title: gptools: AI-Enhanced Tools for Workflow Automation\n[3] description: An in-depth look at gptools, a framework that enables teams to create AI-enhanced scripts for workflow automation.\n- [4] ---\n+ keywords: gptools, AI-enhanced scripts, workflow automation, AI tools, non-developer scripting\n[4] ---\n```\n\nSUMMARY:\n```\nThe title and description of the front matter in the file 'gptools-overview.md' were updated for better SEO. Keywords were also added to improve the document's discoverability.\n```","summary":"The title and description of the front matter in the file 'gptools-overview.md' were updated for better SEO. Keywords were also added to improve the document's discoverability.\n"}}}
{"sha":"50cca088d1d9c576aaa40a30d5c157d3861092f1538d643503d360808fab5aaa","key":{"template":{"id":"front-matter","title":"SEO front matter"},"fragment":{"fullId":"gptools-overview.md.gpspec.md:0:0","hash":"b7521b7869f54be8"}},"val":{"response":{"edits":[],"fileEdits":{"/workspaces/coarch/packages/whitepaper/gptools-overview.md":{"before":"---\ntitle: gptools: Empowering Human Workflows with AI-Enhanced Tools\ndescription: An overview of gptools, a framework that empowers teams to create and use AI-enhanced scripts to support their workflows.\n---\n# gptools: Empowering Human Workflows with AI-Enhanced Tools\n\n-   Authors: Peli de Halleux, Michał Moskal, Ben Zorn\n-   Date: October 2023\n-   Repository: [gptools](https://github.com/microsoft/gptools/tree/main)\n\n## Abstract\n\ngptools is a framework that empowers teams, including non-developers, to create and use AI-enhanced scripts to support their workflows. gptools provides support for creating, understanding, and maintaining complex collections of documents such as software repositories, project management, etc. Our framework leverages foundation models (specifically LLMs) to enable a new kind of scripting that combines traditional code and natural language. The key elements of the gptools framework are **gpspecs** and **gptools**. gpspecs are natural language documents that describe specific user tasks to accomplish. gptools are general scripts that combine traditional software and natural language prompts and rely on an LLM to generate results. We execute gptools in the context of a gpspec to achieve a result. By separating these two abstractions, we allow gptools to be authored, maintained, and updated independently of the gpspecs that use them. The gptools framework includes an execution engine to execute a gptool and an IDE extension to VS Code to support user interaction with the gptool. We believe that gptools will empower even non-developers to automate their workflows in ways that were previously impossible.\n\n## Introduction\n\nThis document describes the gptools framework, which empowers teams, including non-developers, to use AI-enhanced scripts to support their efforts in creating, understanding, and maintaining complex artifacts. gptools leverages foundation models (LLMs) to enable a new kind of scripting that combines traditional code and natural language. To understand how gptools works, we provide an example. The key elements of gptools include gpspecs, gptools, the gpvm, and the gptools extension to VS code.\n\n```mermaid\ngraph LR\nF[User:\\nvia VSCode\\n UI] --> G[gpspec:\\nwrite email\\n recognizer]\nG --> A[gptool:\\ngenerate\\npython code]\nA --> C[gpvm pre:\\nexpand gpspec\\nand gptool\\ninto prompt]\nC --> D[Foundation Model]\nD --> E[gpvm post:\\nextract\\npython code]\nE --> F\n```\n\nThis diagram illustrates the workflow of gptools with a concrete example. The user wants to write a python function that recognizes well-formed email addresses and writes a gpspec. She then invokes a gptool, one that will generate python code from a spec, on that gpspec, much as a user might call a python script with some arguments. The gpvm composes the gpspec with the gptool creating an LLM prompt, which in turn is passed to the foundation model. The foundation model returns a result (python code) to the gpvm, which postprocesses it, creates the requested python file, and notifies the user.\n\nThis document will motivate the design of the gptools framework, illustrate its use with examples, and describe elements of implementation.\n\n## Complex Artifacts Require Complex Workflows\n\n-   Software development is a complex process that requires the coordination of many different activities.\n-   Historically, software development has been a highly manual process, with developers using a variety of tools to create and maintain the artifacts that comprise a software system.\n-   Over time abstractions have been developed to help manage the complexity of software development.\n    -   Important examples include: Unix utilities and pipes, makefiles, build scripts, etc.\n-   Modern software development includes many automated processes as well as manual processes such as code review, design review, bug triage, etc.\n\n## Foundation Models Create New Opportunities\n\n-   The recent development of foundation models (aka LLMs) have created new opportunities for automating complex workflows.\n-   AI has important advantages over traditional software:\n    -   AI models can perform tasks normal software cannot\n    -   AI models can be instructed using natural language, allowing non-programmers to use them\n-   AI models also have disadvantages:\n    -   AI models are not perfect, and can make mistakes\n    -   AI models are not transparent, and it is difficult to understand why they make the decisions they do\n-   AI models are best used to augment human workflows, not replace them\n\n## gptools - a Framework for AI-Enhanced Workflows\n\nVision: empower teams, including non-developers, to use AI-enhanced scripts to support their efforts to create, understand, and maintain complex artifacts\n\nGoals: support tool abstraction, modularity, reuse, but at the same time empower non-developers to author, maintain, and update AI-enhanced scripts\n\nApproach: Foundation models enable a new kind of scripting that allows script writers to achieve both greater functionality and greater ease of use. We separate scripts into two related parts: a generic reusable _gptool_ and a natural language _gpspec_ that instantiates the gptool in a particular context\n\nKey elements of gptools:\n\n-   _gptools_ – Scripts that integrate traditional code and natural language and leverage foundation models in their execution\n-   _gpspecs_ – Natural language documents that instantiate gptools in a particular context\n-   _gpvm_ – A framework and runtime system that executes gpspecs and gptools\n-   _gptools extension to VS code_ – supporting seamless user interaction with gptools\n\n## gptool: A New Kind of Script\n\n-   A gptool is a script with the following components\n\n    -   A header that contains metadata related to the execution of the script (e.g., information about what LLM model to use, etc.)\n    -   A natural language prompt intended to be processed by a foundation model\n    -   An environment context that augments the natural language with additional data/information\n    -   Programming language constructs that are used to programmatically manipulate both inputs and outputs\n\n-   Benefits of gptools\n    -   By separating the gptool from the gpspec, we allow gptools to become highly engineered shared artifacts, forming the basis of shared libraries.\n    -   A gptool can be used in many different contexts, and can be updated and maintained independently of the gpspecs that use it.\n    -   By separating the gptool from the gpspec, we allow non-developers to use gptools without having to understand the details of how they work.\n    -   At the same time, because a gptool contains a natural language prompt, it is easy for a non-developer to understand what the gptool does, and to modify it to suit their needs.\n\n## gpspec: Natural Language to Invoke a gptool\n\nJust as a chat enables a user to interact with an AI model, a gpspec is a natural language markdown document that defines a context in which to invoke a gptool.\n\nA gpspec is a standard markdown file, with the following additional elements:\n\n-   Links to context elements that define the context in which a particular gptool is to be invoked. For example, a gpspec might contain links to markdown files, code files, etc.\n-   Natural language describing the specific task to be performed as input to a gptool. For example, the spec used to generate code would include a description of the functionality and might include a description style guidelines to observe, etc.\n\n. A single gpspec file might be used as input to multiple gptools. For example, a gpspec might be used to generate code, documentation, and tests, each using a different gptool.\n\n## Expanding the Example\n\nTo better understand how gptools work, we expand the example given above. The diagram below illustrates the gptools workflow in greater detail. Our design of gptools is based on the following principles:\n\n-   gptools are used in a context where there is human oversight on the content generated. As a result, our workflow starts and ends with the user.\n-   We assume that the output of a gptool may be incomplete or incorrect, and that the user will need to interact with the output to refine it. As a result, we allow the user to accept/reject and directly modify the AI-generated content.\n-   We assume that the user will want to understand how the AI model was used to generate the results. We provide a trace of how the gpvm composes the gpspec and gptool into a prompt that can be processed by the foundation model.\n-   We support iterative development, where the user can both edit the gpspec and the gptool if they see opportunities to improve the results.\n\n```mermaid\nsequenceDiagram\nparticipant User\nparticipant VSCode\nparticipant gpspec\nparticipant gptool\nparticipant gpvm\nUser->>VSCode: Create/Edit gpspec\nVSCode->>gpspec: Save gpspec\nUser->>VSCode: Invoke gptool\nVSCode->>gptool: Execute gptool with gpspec context\ngptool->>gpvm: Request foundation model execution\ngpvm->>gptool: Return AI-generated output\ngptool->>VSCode: Update context with output\nVSCode->>User: Display updated context\n```\n\nThis diagram demonstrates the AI-enhanced workflow process in gptools. The gpspec instantiates the gptool, which interacts with the gpvm and foundation model. The AI-generated output is used to update the context, and the user interacts with the updated context through the gptools extension to VS code.\n\n### gptool Example: Python Developer gptool\n\nThis is an example of a simple gptool that generates python code from a gpspec file:\n\n```javascript\ngptool({\n    title: \"Generate python code\",\n    model: \"gpt-4\",\n    description: \"Given a task, generate python code.\",\n})\n\ndef(\n    \"CODE\",\n    env.links.filter(\n        (f) => f.filename.endsWith(\".py\") && !f.filename.startsWith(\"test_\")\n    )\n)\ndef(\"TASK\", env.file)\n\n$`Generate python code for the task in TASK. Save code in CODE. If the CODE is already present, ensure that CODE matches the description in TASK and make changes to CODE if it does not.`\n```\n\nIn this example we see the following elements:\n\n-   A header that contains metadata related to the execution of the script (e.g., information about what LLM model to use, etc.)\n-   JavaScript code that manipulates the environment context, specifically by extracting only the python files from the context that do not start with \"test\\_\".\n-   Variable definitions that allow the prompt to refer to elements in the context. TASK refers to the gpspec file, and CODE refers to the python files in the context.\n-   Natural language that combines these elements.\n\n### gpspec Example: Using the Python Developer gptool\n\nThis is an example of a gpspec file that uses the python generating gptool shown above:\n\n```markdown\n# email address and URL recognizer\n\nWrite a function that takes a string argument and returns true if the whole string is a valid email address, false otherwise.\n```\n\nIn this example, there is no additional context needed to invoke the python developer gptool. In other cases, the gpspec file will contain links to additional context elements, such as markdown, code files, etc.\n\n## gpvm - A Framework for Executing gpspecs and gptools\n\nEvery system that interacts with a foundation model includes layers that transform user input into a prompt that can be processed by the foundation model, and layers that transform the output of the foundation model into a form that is useful to the user.\n\n-   gpvm is a runtime environment that:\n    -   Captures the context defined by the gpspec\n    -   Executes whatever code is present in the gptool (in the example above, the variables CODE and TASK are defined by executing JavaScript code)\n    -   Expands the gpspec and natural language of the gptool into a prompt that can be processed by the foundation model\n    -   Sends the results to the AI model\n    -   Processes the results on return to update the user context (which might include creating files, updating files, generating user feedback, etc.)\n\nUnlike many AI model orchestration frameworks, such as Semantic Kernel, gpvm does not leverage the model to do chain-of-thought reasoning or utomatically stage multiple invocations of the AI model during its execution. gptools currently relies on the user to choose and invoke the appropriate gptool as needed.\n\n## gptools Extension to VS Code\n\nWe believe that human oversight of AI models is essential to their effective use. To support this, we have created a VS Code extension that allows a user to interact with a gpspec and gptool in a natural way.\n\nThe extension provides the following capabilities:\n\n-   A command palette that allows a user to select a gptool to invoke in the context of a given gpspec file\n-   A token management system that supports connecting with the AI model of interest\n-   An invocation of the gpvm to process the user input and generate results\n-   A user interface that allows the user to interact with the AI model to refine the results\n-   A gptool trace viewing mechanism that allows users to understand how the AI model was used to generate the results\n\n## Implications of gptools\n\nThe existence of powerful programming tools based on AI that are usable by non-developers is transformative.\n\nJust as the development of JavaScript enabled Web 2.0, and python enabled the creation of the current AI software ecosystem, gptools will fuel a new generation of AI-enhanced applications.\n\nWe envision the creation of gptools for many different verticals, with opportunities for customization and authoring at many levels of expertise:\n\n-   Professional developers and architects will define collections of gptools for a given vertical just as packages are authored and maintained today\n-   Professional developers can author and maintain individual gptools\n-   Developers and non-developers can customize gptools for their particular organization or application needs\n-   Non-developers can author and maintain gpspecs for their particular projects\n\nFurthermore, the existence of gptools can empower non-developers to automate their workflows in ways that were previously impossible.\n\n## Related Work\n\ngptools are related to a number of foundation model projects that automate workflows and encapsulate LLM actions in software artifacts. We describe some of these projects below:\n\n### AI Tools for Developers\n\n-   [GitHub Copilot](https://copilot.github.com/) is a VS Code extension that uses the Codex LLM to suggest code completions based on the context of the current file. Copilot provides LLM support for writing code but does not currently have an extensibility model or a way to create, maintain and apply collections of AI-enhanced scripts.\n-   [codeplan](https://arxiv.org/abs/2309.12499) is a task-agnostic framework that frames repository-level coding as a planning problem, synthesizing a multi-step chain of edits where each step results in a call to an LLM on a code location with context derived from the entire repository, previous code changes, and task-specific instructions. While codeplan uses LLM prompts to generate code, it does not provide a way to create, maintain and apply collections of AI-enhanced scripts.\n\n### LLM Automation/Orchestration Frameworks\n\n-   [autogpt](https://github.com/Significant-Gravitas/AutoGPT) is an AI agent that utilizes a large language model to drive its actions and decisions. Unlike traditional language model applications, AutoGPT does not require repeated prompting by a human and can autonomously develop and manage tasks.\n-   [langchain](https://www.langchain.com/) is a Python library designed to simplify the development of Natural Language Processing (NLP) applications using large language models. It provides a framework for connecting language models to other sources of data and allowing them to interact with their environment.\n-   [semantic kernel](https://github.com/microsoft/semantic-kernel) is an open-source SDK that allows developers to easily integrate AI services with conventional programming languages such as C# and Python. It provides a framework for connecting language models to other sources of data, allowing them to interact with their environment and perform tasks autonomously.\n-   [autogen](https://arxiv.org/abs/2308.08155) is a framework for simplifying the orchestration, optimization, and automation of large language model (LLM) workflows. It offers customizable and conversable agents that leverage LLMs while addressing their limitations by integrating with humans and tools and having conversations between multiple agents via automated chat.\n\ngptools differ from existing AI task automation frameworks in the following ways:\n\n-   gptools are designed to be authored, maintained, and applied by non-developers as well as developers.\n-   gptools define a separation between the gptool and the gpspec that instantiates it, allowing for modularity, reuse, and easier understanding by non-developers.\n-   gptools do not assume task automation and provide a user experience that integrates seamlessly with VS code.\n-   The gptools UI exposes both the content and execution of each gptools to facilitate human oversight and understanding of how the AI model was used to generate the results.\n","after":"---\ntitle: gptools: Empowering Human Workflows with AI-Enhanced Tools\ndescription: An overview of gptools, a framework that empowers teams to create and use AI-enhanced scripts to support their workflows.\n---\n# gptools: Empowering Human Workflows with AI-Enhanced Tools\n\n-   Authors: Peli de Halleux, Michał Moskal, Ben Zorn\n-   Date: October 2023\n-   Repository: [gptools](https://github.com/microsoft/gptools/tree/main)\n\n## Abstract\n\ngptools is a framework that empowers teams, including non-developers, to create and use AI-enhanced scripts to support their workflows. gptools provides support for creating, understanding, and maintaining complex collections of documents such as software repositories, project management, etc. Our framework leverages foundation models (specifically LLMs) to enable a new kind of scripting that combines traditional code and natural language. The key elements of the gptools framework are **gpspecs** and **gptools**. gpspecs are natural language documents that describe specific user tasks to accomplish. gptools are general scripts that combine traditional software and natural language prompts and rely on an LLM to generate results. We execute gptools in the context of a gpspec to achieve a result. By separating these two abstractions, we allow gptools to be authored, maintained, and updated independently of the gpspecs that use them. The gptools framework includes an execution engine to execute a gptool and an IDE extension to VS Code to support user interaction with the gptool. We believe that gptools will empower even non-developers to automate their workflows in ways that were previously impossible.\n\n## Introduction\n\nThis document describes the gptools framework, which empowers teams, including non-developers, to use AI-enhanced scripts to support their efforts in creating, understanding, and maintaining complex artifacts. gptools leverages foundation models (LLMs) to enable a new kind of scripting that combines traditional code and natural language. To understand how gptools works, we provide an example. The key elements of gptools include gpspecs, gptools, the gpvm, and the gptools extension to VS code.\n\n```mermaid\ngraph LR\nF[User:\\nvia VSCode\\n UI] --> G[gpspec:\\nwrite email\\n recognizer]\nG --> A[gptool:\\ngenerate\\npython code]\nA --> C[gpvm pre:\\nexpand gpspec\\nand gptool\\ninto prompt]\nC --> D[Foundation Model]\nD --> E[gpvm post:\\nextract\\npython code]\nE --> F\n```\n\nThis diagram illustrates the workflow of gptools with a concrete example. The user wants to write a python function that recognizes well-formed email addresses and writes a gpspec. She then invokes a gptool, one that will generate python code from a spec, on that gpspec, much as a user might call a python script with some arguments. The gpvm composes the gpspec with the gptool creating an LLM prompt, which in turn is passed to the foundation model. The foundation model returns a result (python code) to the gpvm, which postprocesses it, creates the requested python file, and notifies the user.\n\nThis document will motivate the design of the gptools framework, illustrate its use with examples, and describe elements of implementation.\n\n## Complex Artifacts Require Complex Workflows\n\n-   Software development is a complex process that requires the coordination of many different activities.\n-   Historically, software development has been a highly manual process, with developers using a variety of tools to create and maintain the artifacts that comprise a software system.\n-   Over time abstractions have been developed to help manage the complexity of software development.\n    -   Important examples include: Unix utilities and pipes, makefiles, build scripts, etc.\n-   Modern software development includes many automated processes as well as manual processes such as code review, design review, bug triage, etc.\n\n## Foundation Models Create New Opportunities\n\n-   The recent development of foundation models (aka LLMs) have created new opportunities for automating complex workflows.\n-   AI has important advantages over traditional software:\n    -   AI models can perform tasks normal software cannot\n    -   AI models can be instructed using natural language, allowing non-programmers to use them\n-   AI models also have disadvantages:\n    -   AI models are not perfect, and can make mistakes\n    -   AI models are not transparent, and it is difficult to understand why they make the decisions they do\n-   AI models are best used to augment human workflows, not replace them\n\n## gptools - a Framework for AI-Enhanced Workflows\n\nVision: empower teams, including non-developers, to use AI-enhanced scripts to support their efforts to create, understand, and maintain complex artifacts\n\nGoals: support tool abstraction, modularity, reuse, but at the same time empower non-developers to author, maintain, and update AI-enhanced scripts\n\nApproach: Foundation models enable a new kind of scripting that allows script writers to achieve both greater functionality and greater ease of use. We separate scripts into two related parts: a generic reusable _gptool_ and a natural language _gpspec_ that instantiates the gptool in a particular context\n\nKey elements of gptools:\n\n-   _gptools_ – Scripts that integrate traditional code and natural language and leverage foundation models in their execution\n-   _gpspecs_ – Natural language documents that instantiate gptools in a particular context\n-   _gpvm_ – A framework and runtime system that executes gpspecs and gptools\n-   _gptools extension to VS code_ – supporting seamless user interaction with gptools\n\n## gptool: A New Kind of Script\n\n-   A gptool is a script with the following components\n\n    -   A header that contains metadata related to the execution of the script (e.g., information about what LLM model to use, etc.)\n    -   A natural language prompt intended to be processed by a foundation model\n    -   An environment context that augments the natural language with additional data/information\n    -   Programming language constructs that are used to programmatically manipulate both inputs and outputs\n\n-   Benefits of gptools\n    -   By separating the gptool from the gpspec, we allow gptools to become highly engineered shared artifacts, forming the basis of shared libraries.\n    -   A gptool can be used in many different contexts, and can be updated and maintained independently of the gpspecs that use it.\n    -   By separating the gptool from the gpspec, we allow non-developers to use gptools without having to understand the details of how they work.\n    -   At the same time, because a gptool contains a natural language prompt, it is easy for a non-developer to understand what the gptool does, and to modify it to suit their needs.\n\n## gpspec: Natural Language to Invoke a gptool\n\nJust as a chat enables a user to interact with an AI model, a gpspec is a natural language markdown document that defines a context in which to invoke a gptool.\n\nA gpspec is a standard markdown file, with the following additional elements:\n\n-   Links to context elements that define the context in which a particular gptool is to be invoked. For example, a gpspec might contain links to markdown files, code files, etc.\n-   Natural language describing the specific task to be performed as input to a gptool. For example, the spec used to generate code would include a description of the functionality and might include a description style guidelines to observe, etc.\n\n. A single gpspec file might be used as input to multiple gptools. For example, a gpspec might be used to generate code, documentation, and tests, each using a different gptool.\n\n## Expanding the Example\n\nTo better understand how gptools work, we expand the example given above. The diagram below illustrates the gptools workflow in greater detail. Our design of gptools is based on the following principles:\n\n-   gptools are used in a context where there is human oversight on the content generated. As a result, our workflow starts and ends with the user.\n-   We assume that the output of a gptool may be incomplete or incorrect, and that the user will need to interact with the output to refine it. As a result, we allow the user to accept/reject and directly modify the AI-generated content.\n-   We assume that the user will want to understand how the AI model was used to generate the results. We provide a trace of how the gpvm composes the gpspec and gptool into a prompt that can be processed by the foundation model.\n-   We support iterative development, where the user can both edit the gpspec and the gptool if they see opportunities to improve the results.\n\n```mermaid\nsequenceDiagram\nparticipant User\nparticipant VSCode\nparticipant gpspec\nparticipant gptool\nparticipant gpvm\nUser->>VSCode: Create/Edit gpspec\nVSCode->>gpspec: Save gpspec\nUser->>VSCode: Invoke gptool\nVSCode->>gptool: Execute gptool with gpspec context\ngptool->>gpvm: Request foundation model execution\ngpvm->>gptool: Return AI-generated output\ngptool->>VSCode: Update context with output\nVSCode->>User: Display updated context\n```\n\nThis diagram demonstrates the AI-enhanced workflow process in gptools. The gpspec instantiates the gptool, which interacts with the gpvm and foundation model. The AI-generated output is used to update the context, and the user interacts with the updated context through the gptools extension to VS code.\n\n### gptool Example: Python Developer gptool\n\nThis is an example of a simple gptool that generates python code from a gpspec file:\n\n```javascript\ngptool({\n    title: \"Generate python code\",\n    model: \"gpt-4\",\n    description: \"Given a task, generate python code.\",\n})\n\ndef(\n    \"CODE\",\n    env.links.filter(\n        (f) => f.filename.endsWith(\".py\") && !f.filename.startsWith(\"test_\")\n    )\n)\ndef(\"TASK\", env.file)\n\n$`Generate python code for the task in TASK. Save code in CODE. If the CODE is already present, ensure that CODE matches the description in TASK and make changes to CODE if it does not.`\n```\n\nIn this example we see the following elements:\n\n-   A header that contains metadata related to the execution of the script (e.g., information about what LLM model to use, etc.)\n-   JavaScript code that manipulates the environment context, specifically by extracting only the python files from the context that do not start with \"test\\_\".\n-   Variable definitions that allow the prompt to refer to elements in the context. TASK refers to the gpspec file, and CODE refers to the python files in the context.\n-   Natural language that combines these elements.\n\n### gpspec Example: Using the Python Developer gptool\n\nThis is an example of a gpspec file that uses the python generating gptool shown above:\n\n```markdown\n# email address and URL recognizer\n\nWrite a function that takes a string argument and returns true if the whole string is a valid email address, false otherwise.\n```\n\nIn this example, there is no additional context needed to invoke the python developer gptool. In other cases, the gpspec file will contain links to additional context elements, such as markdown, code files, etc.\n\n## gpvm - A Framework for Executing gpspecs and gptools\n\nEvery system that interacts with a foundation model includes layers that transform user input into a prompt that can be processed by the foundation model, and layers that transform the output of the foundation model into a form that is useful to the user.\n\n-   gpvm is a runtime environment that:\n    -   Captures the context defined by the gpspec\n    -   Executes whatever code is present in the gptool (in the example above, the variables CODE and TASK are defined by executing JavaScript code)\n    -   Expands the gpspec and natural language of the gptool into a prompt that can be processed by the foundation model\n    -   Sends the results to the AI model\n    -   Processes the results on return to update the user context (which might include creating files, updating files, generating user feedback, etc.)\n\nUnlike many AI model orchestration frameworks, such as Semantic Kernel, gpvm does not leverage the model to do chain-of-thought reasoning or utomatically stage multiple invocations of the AI model during its execution. gptools currently relies on the user to choose and invoke the appropriate gptool as needed.\n\n## gptools Extension to VS Code\n\nWe believe that human oversight of AI models is essential to their effective use. To support this, we have created a VS Code extension that allows a user to interact with a gpspec and gptool in a natural way.\n\nThe extension provides the following capabilities:\n\n-   A command palette that allows a user to select a gptool to invoke in the context of a given gpspec file\n-   A token management system that supports connecting with the AI model of interest\n-   An invocation of the gpvm to process the user input and generate results\n-   A user interface that allows the user to interact with the AI model to refine the results\n-   A gptool trace viewing mechanism that allows users to understand how the AI model was used to generate the results\n\n## Implications of gptools\n\nThe existence of powerful programming tools based on AI that are usable by non-developers is transformative.\n\nJust as the development of JavaScript enabled Web 2.0, and python enabled the creation of the current AI software ecosystem, gptools will fuel a new generation of AI-enhanced applications.\n\nWe envision the creation of gptools for many different verticals, with opportunities for customization and authoring at many levels of expertise:\n\n-   Professional developers and architects will define collections of gptools for a given vertical just as packages are authored and maintained today\n-   Professional developers can author and maintain individual gptools\n-   Developers and non-developers can customize gptools for their particular organization or application needs\n-   Non-developers can author and maintain gpspecs for their particular projects\n\nFurthermore, the existence of gptools can empower non-developers to automate their workflows in ways that were previously impossible.\n\n## Related Work\n\ngptools are related to a number of foundation model projects that automate workflows and encapsulate LLM actions in software artifacts. We describe some of these projects below:\n\n### AI Tools for Developers\n\n-   [GitHub Copilot](https://copilot.github.com/) is a VS Code extension that uses the Codex LLM to suggest code completions based on the context of the current file. Copilot provides LLM support for writing code but does not currently have an extensibility model or a way to create, maintain and apply collections of AI-enhanced scripts.\n-   [codeplan](https://arxiv.org/abs/2309.12499) is a task-agnostic framework that frames repository-level coding as a planning problem, synthesizing a multi-step chain of edits where each step results in a call to an LLM on a code location with context derived from the entire repository, previous code changes, and task-specific instructions. While codeplan uses LLM prompts to generate code, it does not provide a way to create, maintain and apply collections of AI-enhanced scripts.\n\n### LLM Automation/Orchestration Frameworks\n\n-   [autogpt](https://github.com/Significant-Gravitas/AutoGPT) is an AI agent that utilizes a large language model to drive its actions and decisions. Unlike traditional language model applications, AutoGPT does not require repeated prompting by a human and can autonomously develop and manage tasks.\n-   [langchain](https://www.langchain.com/) is a Python library designed to simplify the development of Natural Language Processing (NLP) applications using large language models. It provides a framework for connecting language models to other sources of data and allowing them to interact with their environment.\n-   [semantic kernel](https://github.com/microsoft/semantic-kernel) is an open-source SDK that allows developers to easily integrate AI services with conventional programming languages such as C# and Python. It provides a framework for connecting language models to other sources of data, allowing them to interact with their environment and perform tasks autonomously.\n-   [autogen](https://arxiv.org/abs/2308.08155) is a framework for simplifying the orchestration, optimization, and automation of large language model (LLM) workflows. It offers customizable and conversable agents that leverage LLMs while addressing their limitations by integrating with humans and tools and having conversations between multiple agents via automated chat.\n\ngptools differ from existing AI task automation frameworks in the following ways:\n\n-   gptools are designed to be authored, maintained, and applied by non-developers as well as developers.\n-   gptools define a separation between the gptool and the gpspec that instantiates it, allowing for modularity, reuse, and easier understanding by non-developers.\n-   gptools do not assume task automation and provide a user experience that integrates seamlessly with VS code.\n-   The gptools UI exposes both the content and execution of each gptools to facilitate human oversight and understanding of how the AI model was used to generate the results.\n"}},"trace":"\n# `front-matter` trace\n\n\n\n## gptool source\n\n\n```js\ngptool({\n    title: \"SEO front matter\",\n    description:\n        \"Update or generate SEO-optimized front matter for a markdown file.\",\n    categories: [\"samples\"],\n    system: [\"system\", \"system.diff\", \"system.summary\"],\n    maxTokens: 2000,\n    temperature: 0,\n})\n\ndef(\n    \"FILE\",\n    env.links.filter((f) => f.filename.endsWith(\".md\")), { lineNumbers: true }\n)\n\n$`\nYou are a search engine optimization expert at creating front matter for markdown document.\n\nUpdate or generate front matter in FILE:\n- Update fields title, description and keywords as needed\n- use yaml format, do not use quotes\n- only 5 keywords or less\n- optimize for search engine optimization.\n- Do NOT modify the markdown content after the front matter\n\nIf no front matter is present, generate it.\n`\n```\n\n\n\n## console output\n> tip: use `console.log()` from gptool.js files\n## expanded prompt\n\n``````markdown\nFILE:\n````` file=gptools-overview.md\n[1] ---\n[2] title: gptools: Empowering Human Workflows with AI-Enhanced Tools\n[3] description: An overview of gptools, a framework that empowers teams to create and use AI-enhanced scripts to support their workflows.\n[4] ---\n[5] # gptools: Empowering Human Workflows with AI-Enhanced Tools\n[6] \n[7] -   Authors: Peli de Halleux, Michał Moskal, Ben Zorn\n[8] -   Date: October 2023\n[9] -   Repository: [gptools](https://github.com/microsoft/gptools/tree/main)\n[10] \n[11] ## Abstract\n[12] \n[13] gptools is a framework that empowers teams, including non-developers, to create and use AI-enhanced scripts to support their workflows. gptools provides support for creating, understanding, and maintaining complex collections of documents such as software repositories, project management, etc. Our framework leverages foundation models (specifically LLMs) to enable a new kind of scripting that combines traditional code and natural language. The key elements of the gptools framework are **gpspecs** and **gptools**. gpspecs are natural language documents that describe specific user tasks to accomplish. gptools are general scripts that combine traditional software and natural language prompts and rely on an LLM to generate results. We execute gptools in the context of a gpspec to achieve a result. By separating these two abstractions, we allow gptools to be authored, maintained, and updated independently of the gpspecs that use them. The gptools framework includes an execution engine to execute a gptool and an IDE extension to VS Code to support user interaction with the gptool. We believe that gptools will empower even non-developers to automate their workflows in ways that were previously impossible.\n[14] \n[15] ## Introduction\n[16] \n[17] This document describes the gptools framework, which empowers teams, including non-developers, to use AI-enhanced scripts to support their efforts in creating, understanding, and maintaining complex artifacts. gptools leverages foundation models (LLMs) to enable a new kind of scripting that combines traditional code and natural language. To understand how gptools works, we provide an example. The key elements of gptools include gpspecs, gptools, the gpvm, and the gptools extension to VS code.\n[18] \n[19] ```mermaid\n[20] graph LR\n[21] F[User:\\nvia VSCode\\n UI] --> G[gpspec:\\nwrite email\\n recognizer]\n[22] G --> A[gptool:\\ngenerate\\npython code]\n[23] A --> C[gpvm pre:\\nexpand gpspec\\nand gptool\\ninto prompt]\n[24] C --> D[Foundation Model]\n[25] D --> E[gpvm post:\\nextract\\npython code]\n[26] E --> F\n[27] ```\n[28] \n[29] This diagram illustrates the workflow of gptools with a concrete example. The user wants to write a python function that recognizes well-formed email addresses and writes a gpspec. She then invokes a gptool, one that will generate python code from a spec, on that gpspec, much as a user might call a python script with some arguments. The gpvm composes the gpspec with the gptool creating an LLM prompt, which in turn is passed to the foundation model. The foundation model returns a result (python code) to the gpvm, which postprocesses it, creates the requested python file, and notifies the user.\n[30] \n[31] This document will motivate the design of the gptools framework, illustrate its use with examples, and describe elements of implementation.\n[32] \n[33] ## Complex Artifacts Require Complex Workflows\n[34] \n[35] -   Software development is a complex process that requires the coordination of many different activities.\n[36] -   Historically, software development has been a highly manual process, with developers using a variety of tools to create and maintain the artifacts that comprise a software system.\n[37] -   Over time abstractions have been developed to help manage the complexity of software development.\n[38]     -   Important examples include: Unix utilities and pipes, makefiles, build scripts, etc.\n[39] -   Modern software development includes many automated processes as well as manual processes such as code review, design review, bug triage, etc.\n[40] \n[41] ## Foundation Models Create New Opportunities\n[42] \n[43] -   The recent development of foundation models (aka LLMs) have created new opportunities for automating complex workflows.\n[44] -   AI has important advantages over traditional software:\n[45]     -   AI models can perform tasks normal software cannot\n[46]     -   AI models can be instructed using natural language, allowing non-programmers to use them\n[47] -   AI models also have disadvantages:\n[48]     -   AI models are not perfect, and can make mistakes\n[49]     -   AI models are not transparent, and it is difficult to understand why they make the decisions they do\n[50] -   AI models are best used to augment human workflows, not replace them\n[51] \n[52] ## gptools - a Framework for AI-Enhanced Workflows\n[53] \n[54] Vision: empower teams, including non-developers, to use AI-enhanced scripts to support their efforts to create, understand, and maintain complex artifacts\n[55] \n[56] Goals: support tool abstraction, modularity, reuse, but at the same time empower non-developers to author, maintain, and update AI-enhanced scripts\n[57] \n[58] Approach: Foundation models enable a new kind of scripting that allows script writers to achieve both greater functionality and greater ease of use. We separate scripts into two related parts: a generic reusable _gptool_ and a natural language _gpspec_ that instantiates the gptool in a particular context\n[59] \n[60] Key elements of gptools:\n[61] \n[62] -   _gptools_ – Scripts that integrate traditional code and natural language and leverage foundation models in their execution\n[63] -   _gpspecs_ – Natural language documents that instantiate gptools in a particular context\n[64] -   _gpvm_ – A framework and runtime system that executes gpspecs and gptools\n[65] -   _gptools extension to VS code_ – supporting seamless user interaction with gptools\n[66] \n[67] ## gptool: A New Kind of Script\n[68] \n[69] -   A gptool is a script with the following components\n[70] \n[71]     -   A header that contains metadata related to the execution of the script (e.g., information about what LLM model to use, etc.)\n[72]     -   A natural language prompt intended to be processed by a foundation model\n[73]     -   An environment context that augments the natural language with additional data/information\n[74]     -   Programming language constructs that are used to programmatically manipulate both inputs and outputs\n[75] \n[76] -   Benefits of gptools\n[77]     -   By separating the gptool from the gpspec, we allow gptools to become highly engineered shared artifacts, forming the basis of shared libraries.\n[78]     -   A gptool can be used in many different contexts, and can be updated and maintained independently of the gpspecs that use it.\n[79]     -   By separating the gptool from the gpspec, we allow non-developers to use gptools without having to understand the details of how they work.\n[80]     -   At the same time, because a gptool contains a natural language prompt, it is easy for a non-developer to understand what the gptool does, and to modify it to suit their needs.\n[81] \n[82] ## gpspec: Natural Language to Invoke a gptool\n[83] \n[84] Just as a chat enables a user to interact with an AI model, a gpspec is a natural language markdown document that defines a context in which to invoke a gptool.\n[85] \n[86] A gpspec is a standard markdown file, with the following additional elements:\n[87] \n[88] -   Links to context elements that define the context in which a particular gptool is to be invoked. For example, a gpspec might contain links to markdown files, code files, etc.\n[89] -   Natural language describing the specific task to be performed as input to a gptool. For example, the spec used to generate code would include a description of the functionality and might include a description style guidelines to observe, etc.\n[90] \n[91] . A single gpspec file might be used as input to multiple gptools. For example, a gpspec might be used to generate code, documentation, and tests, each using a different gptool.\n[92] \n[93] ## Expanding the Example\n[94] \n[95] To better understand how gptools work, we expand the example given above. The diagram below illustrates the gptools workflow in greater detail. Our design of gptools is based on the following principles:\n[96] \n[97] -   gptools are used in a context where there is human oversight on the content generated. As a result, our workflow starts and ends with the user.\n[98] -   We assume that the output of a gptool may be incomplete or incorrect, and that the user will need to interact with the output to refine it. As a result, we allow the user to accept/reject and directly modify the AI-generated content.\n[99] -   We assume that the user will want to understand how the AI model was used to generate the results. We provide a trace of how the gpvm composes the gpspec and gptool into a prompt that can be processed by the foundation model.\n[100] -   We support iterative development, where the user can both edit the gpspec and the gptool if they see opportunities to improve the results.\n[101] \n[102] ```mermaid\n[103] sequenceDiagram\n[104] participant User\n[105] participant VSCode\n[106] participant gpspec\n[107] participant gptool\n[108] participant gpvm\n[109] User->>VSCode: Create/Edit gpspec\n[110] VSCode->>gpspec: Save gpspec\n[111] User->>VSCode: Invoke gptool\n[112] VSCode->>gptool: Execute gptool with gpspec context\n[113] gptool->>gpvm: Request foundation model execution\n[114] gpvm->>gptool: Return AI-generated output\n[115] gptool->>VSCode: Update context with output\n[116] VSCode->>User: Display updated context\n[117] ```\n[118] \n[119] This diagram demonstrates the AI-enhanced workflow process in gptools. The gpspec instantiates the gptool, which interacts with the gpvm and foundation model. The AI-generated output is used to update the context, and the user interacts with the updated context through the gptools extension to VS code.\n[120] \n[121] ### gptool Example: Python Developer gptool\n[122] \n[123] This is an example of a simple gptool that generates python code from a gpspec file:\n[124] \n[125] ```javascript\n[126] gptool({\n[127]     title: \"Generate python code\",\n[128]     model: \"gpt-4\",\n[129]     description: \"Given a task, generate python code.\",\n[130] })\n[131] \n[132] def(\n[133]     \"CODE\",\n[134]     env.links.filter(\n[135]         (f) => f.filename.endsWith(\".py\") && !f.filename.startsWith(\"test_\")\n[136]     )\n[137] )\n[138] def(\"TASK\", env.file)\n[139] \n[140] $`Generate python code for the task in TASK. Save code in CODE. If the CODE is already present, ensure that CODE matches the description in TASK and make changes to CODE if it does not.`\n[141] ```\n[142] \n[143] In this example we see the following elements:\n[144] \n[145] -   A header that contains metadata related to the execution of the script (e.g., information about what LLM model to use, etc.)\n[146] -   JavaScript code that manipulates the environment context, specifically by extracting only the python files from the context that do not start with \"test\\_\".\n[147] -   Variable definitions that allow the prompt to refer to elements in the context. TASK refers to the gpspec file, and CODE refers to the python files in the context.\n[148] -   Natural language that combines these elements.\n[149] \n[150] ### gpspec Example: Using the Python Developer gptool\n[151] \n[152] This is an example of a gpspec file that uses the python generating gptool shown above:\n[153] \n[154] ```markdown\n[155] # email address and URL recognizer\n[156] \n[157] Write a function that takes a string argument and returns true if the whole string is a valid email address, false otherwise.\n[158] ```\n[159] \n[160] In this example, there is no additional context needed to invoke the python developer gptool. In other cases, the gpspec file will contain links to additional context elements, such as markdown, code files, etc.\n[161] \n[162] ## gpvm - A Framework for Executing gpspecs and gptools\n[163] \n[164] Every system that interacts with a foundation model includes layers that transform user input into a prompt that can be processed by the foundation model, and layers that transform the output of the foundation model into a form that is useful to the user.\n[165] \n[166] -   gpvm is a runtime environment that:\n[167]     -   Captures the context defined by the gpspec\n[168]     -   Executes whatever code is present in the gptool (in the example above, the variables CODE and TASK are defined by executing JavaScript code)\n[169]     -   Expands the gpspec and natural language of the gptool into a prompt that can be processed by the foundation model\n[170]     -   Sends the results to the AI model\n[171]     -   Processes the results on return to update the user context (which might include creating files, updating files, generating user feedback, etc.)\n[172] \n[173] Unlike many AI model orchestration frameworks, such as Semantic Kernel, gpvm does not leverage the model to do chain-of-thought reasoning or utomatically stage multiple invocations of the AI model during its execution. gptools currently relies on the user to choose and invoke the appropriate gptool as needed.\n[174] \n[175] ## gptools Extension to VS Code\n[176] \n[177] We believe that human oversight of AI models is essential to their effective use. To support this, we have created a VS Code extension that allows a user to interact with a gpspec and gptool in a natural way.\n[178] \n[179] The extension provides the following capabilities:\n[180] \n[181] -   A command palette that allows a user to select a gptool to invoke in the context of a given gpspec file\n[182] -   A token management system that supports connecting with the AI model of interest\n[183] -   An invocation of the gpvm to process the user input and generate results\n[184] -   A user interface that allows the user to interact with the AI model to refine the results\n[185] -   A gptool trace viewing mechanism that allows users to understand how the AI model was used to generate the results\n[186] \n[187] ## Implications of gptools\n[188] \n[189] The existence of powerful programming tools based on AI that are usable by non-developers is transformative.\n[190] \n[191] Just as the development of JavaScript enabled Web 2.0, and python enabled the creation of the current AI software ecosystem, gptools will fuel a new generation of AI-enhanced applications.\n[192] \n[193] We envision the creation of gptools for many different verticals, with opportunities for customization and authoring at many levels of expertise:\n[194] \n[195] -   Professional developers and architects will define collections of gptools for a given vertical just as packages are authored and maintained today\n[196] -   Professional developers can author and maintain individual gptools\n[197] -   Developers and non-developers can customize gptools for their particular organization or application needs\n[198] -   Non-developers can author and maintain gpspecs for their particular projects\n[199] \n[200] Furthermore, the existence of gptools can empower non-developers to automate their workflows in ways that were previously impossible.\n[201] \n[202] ## Related Work\n[203] \n[204] gptools are related to a number of foundation model projects that automate workflows and encapsulate LLM actions in software artifacts. We describe some of these projects below:\n[205] \n[206] ### AI Tools for Developers\n[207] \n[208] -   [GitHub Copilot](https://copilot.github.com/) is a VS Code extension that uses the Codex LLM to suggest code completions based on the context of the current file. Copilot provides LLM support for writing code but does not currently have an extensibility model or a way to create, maintain and apply collections of AI-enhanced scripts.\n[209] -   [codeplan](https://arxiv.org/abs/2309.12499) is a task-agnostic framework that frames repository-level coding as a planning problem, synthesizing a multi-step chain of edits where each step results in a call to an LLM on a code location with context derived from the entire repository, previous code changes, and task-specific instructions. While codeplan uses LLM prompts to generate code, it does not provide a way to create, maintain and apply collections of AI-enhanced scripts.\n[210] \n[211] ### LLM Automation/Orchestration Frameworks\n[212] \n[213] -   [autogpt](https://github.com/Significant-Gravitas/AutoGPT) is an AI agent that utilizes a large language model to drive its actions and decisions. Unlike traditional language model applications, AutoGPT does not require repeated prompting by a human and can autonomously develop and manage tasks.\n[214] -   [langchain](https://www.langchain.com/) is a Python library designed to simplify the development of Natural Language Processing (NLP) applications using large language models. It provides a framework for connecting language models to other sources of data and allowing them to interact with their environment.\n[215] -   [semantic kernel](https://github.com/microsoft/semantic-kernel) is an open-source SDK that allows developers to easily integrate AI services with conventional programming languages such as C# and Python. It provides a framework for connecting language models to other sources of data, allowing them to interact with their environment and perform tasks autonomously.\n[216] -   [autogen](https://arxiv.org/abs/2308.08155) is a framework for simplifying the orchestration, optimization, and automation of large language model (LLM) workflows. It offers customizable and conversable agents that leverage LLMs while addressing their limitations by integrating with humans and tools and having conversations between multiple agents via automated chat.\n[217] \n[218] gptools differ from existing AI task automation frameworks in the following ways:\n[219] \n[220] -   gptools are designed to be authored, maintained, and applied by non-developers as well as developers.\n[221] -   gptools define a separation between the gptool and the gpspec that instantiates it, allowing for modularity, reuse, and easier understanding by non-developers.\n[222] -   gptools do not assume task automation and provide a user experience that integrates seamlessly with VS code.\n[223] -   The gptools UI exposes both the content and execution of each gptools to facilitate human oversight and understanding of how the AI model was used to generate the results.\n`````\n\nYou are a search engine optimization expert at creating front matter for markdown document.\n\nUpdate or generate front matter in FILE:\n- Update fields title, description and keywords as needed\n- use yaml format, do not use quotes\n- only 5 keywords or less\n- optimize for search engine optimization.\n- Do NOT modify the markdown content after the front matter\n\nIf no front matter is present, generate it.\n``````\n\n\n## variables\n> Variables are referenced through `env.NAME` in prompts.\n\n-   env.**error**: `ERROR-JNDQVP`\n\n-   env.**file**\n```js\n{ filename: \"gptools-overview.md.gpspec.md\",\nlabel: \"current\",\ncontent: \"# gptools-overview.md\\n\\n-   [gptools-overview.md](./gptools-o\"... }\n```\n\n-   env.**links**\n```js\n[ { label: \"gptools-overview.md\",\n  filename: \"gptools-overview.md\",\n  content: \"---\\ntitle: gptools: Empowering Human Workflows with AI-Enhan\"... } ]\n```\n\n-   env.**parents**\n```js\n[  ]\n```\n\n-   env.**fence**\n``````markdown\n```\n``````\n\n-   env.**markdownFence**\n``````markdown\n`````\n``````\n\n-   env.**promptOptions**\n```js\n{  }\n```\n\n-   env.**vars**\n```js\n{  }\n```\n\n-   env.**templates**\n```js\n[ { id: \"add-comments\",\n  title: \"Add Comments\",\n  description: \"Review each chapter and adds a comment as a technical review\"... },\n{ id: \"slides\",\n  title: \"Generate Slides\",\n  description: \"Generate a slidedeck in markdown\" },\n{ id: \"bug-with-output-spec_2\",\n  title: \"gen to non-coarch file\",\n  description: \"Given files about a project and the goal of writing a white \"... },\n{ id: \"generate-1pager\",\n  title: \"generate 1 pager\",\n  description: \"Given markdown files describing a project, generate 1 page o\"... },\n{ id: \"generate-diagrams\",\n  title: \"generate diagrams\",\n  description: \"Given markdown files describing a project, mermaid diagrams \"... },\n{ id: \"generate-abstract\",\n  title: \"generate-abstract\",\n  description: \"Given files about a project and the goal of writing a white \"... },\n{ id: \"generate-introduction\",\n  title: \"generate-introduction\",\n  description: \"Given files about a project and the goal of writing a white \"... },\n{ id: \"generate-outline\",\n  title: \"generate-outline\",\n  description: \"Given markdown files describing a project, generate an outli\"... },\n{ id: \"summarize-project\",\n  title: \"summarize-project\",\n  description: \"Given markdown files describing a project, generate a summar\"... },\n{ id: \"code-optimizer\",\n  title: \"Code Optimizer\",\n  description: \"Optimize code to run faster, modified from https://twitter.c\"... },\n{ id: \"code-xray\",\n  title: \"Code XRay\",\n  description: \"Given a source file in a programming language, extract the s\"... },\n{ id: \"core.default\",\n  title: \"Run gpspec directly\",\n  description: \"This is the default gptool that assumes the gpspec contains \"... },\n{ id: \"front-matter\",\n  title: \"SEO front matter\",\n  description: \"Update or generate SEO-optimized front matter for a markdown\"... },\n{ id: \"peer-review\",\n  title: \"peer review\",\n  description: \"An expert academic is reviewing your submission.\" } ]\n```\n\n-   env.**template**\n```js\n{ id: \"front-matter\",\ntitle: \"SEO front matter\",\ntext: \"<nothing yet>\",\njsSource: \"gptool({\\n    title: \\\"SEO front matter\\\",\\n    description:\\n   \"...,\ndescription: \"Update or generate SEO-optimized front matter for a markdown\"...,\ncategories: [ \"samples\" ],\nsystem: [ \"system\",\n  \"system.diff\",\n  \"system.summary\" ],\nmaxTokens: 2000,\ntemperature: 0,\ninput: \".md\" }\n```\n\n## system prompts\n###  `system`\n\n```js\nsystem({ title: \"System prompt\" })\n$`You are concise. Answer in markdown.`\n```\n#### expanded system prompt\n``````markdown\nYou are concise. Answer in markdown.\n``````\n###  `system.diff`\n\n```js\nsystem({ title: \"Diff generation\", description: \"Teaches the diff file format supported by GPTools\" })\n\n$`The DIFF format should be used to generate diff changes on files: added lines start with +\n, deleted lines start with -\n, do not add line numbers\n, preserve indentation\n, use relative file path name\n, only generate diff for files that have changes\n, do NOT generate diff for files that have no changes\n, only emit a couple unmodified lines before and after the changes\n, do NOT emit the whole file content\n, deleted lines MUST exist in the original file (do not invent deleted lines)\n, added lines MUST not exist in the original file\n, emit line numbers from existing lines\n, do NOT emit line numbers for added lines and deleted lines\n, keep the diffs as small as possible:\n\nDIFF ./file.ts:\n${env.fence}diff\n[original line number]  <2 lines before changes (not the whole file)>\n- <deleted line>\n- <delete line 2>\n~ [original line number] <modified line>\n~ [original line number] <modified line 2>\n+ <added line>\n+ <added line 2>\n[original line number]   <2 lines after changes (not the whole file)>\n${env.fence}\n\nDIFF ./file2.ts:\n${env.fence}diff\n[original line number]   <2 lines before changes (not the whole file)>\n- <deleted line>\n- <delete line 2>\n~ [original line number] <modified line>\n~ [original line number] <modified line 2>\n+ <added line>\n+ <added line 2>\n[original line number]   <2 lines after changes (not the whole file)>\n${env.fence}\n`\n\n$`Do not generate anything else than DIFF sections. Use one DIFF section per change.`\n```\n#### expanded system prompt\n``````markdown\nThe DIFF format should be used to generate diff changes on files: added lines start with +\n, deleted lines start with -\n, do not add line numbers\n, preserve indentation\n, use relative file path name\n, only generate diff for files that have changes\n, do NOT generate diff for files that have no changes\n, only emit a couple unmodified lines before and after the changes\n, do NOT emit the whole file content\n, deleted lines MUST exist in the original file (do not invent deleted lines)\n, added lines MUST not exist in the original file\n, emit line numbers from existing lines\n, do NOT emit line numbers for added lines and deleted lines\n, keep the diffs as small as possible:\n\nDIFF ./file.ts:\n```diff\n[original line number]  <2 lines before changes (not the whole file)>\n- <deleted line>\n- <delete line 2>\n~ [original line number] <modified line>\n~ [original line number] <modified line 2>\n+ <added line>\n+ <added line 2>\n[original line number]   <2 lines after changes (not the whole file)>\n```\n\nDIFF ./file2.ts:\n```diff\n[original line number]   <2 lines before changes (not the whole file)>\n- <deleted line>\n- <delete line 2>\n~ [original line number] <modified line>\n~ [original line number] <modified line 2>\n+ <added line>\n+ <added line 2>\n[original line number]   <2 lines after changes (not the whole file)>\n```\n\nDo not generate anything else than DIFF sections. Use one DIFF section per change.\n``````\n###  `system.summary`\n\n```js\nsystem({\n    title: \"Summarize\",\n    description: \"Generate a summary of the changes\",\n})\n\n$`Additionally, generate a concise SUMMARY of the changes in all files using the following syntax:`\n\ndef(`SUMMARY`, `This is a summary of the changes in files.`)\n```\n#### expanded system prompt\n``````markdown\nAdditionally, generate a concise SUMMARY of the changes in all files using the following syntax:\n\nSUMMARY:\n```\nThis is a summary of the changes in files.\n```\n``````\n\n\n## final prompt\n\n-  model: `gpt-4`\n-  temperature: \n-  max tokens: 2000\n\n``````markdown\nFILE:\n````` file=gptools-overview.md\n[1] ---\n[2] title: gptools: Empowering Human Workflows with AI-Enhanced Tools\n[3] description: An overview of gptools, a framework that empowers teams to create and use AI-enhanced scripts to support their workflows.\n[4] ---\n[5] # gptools: Empowering Human Workflows with AI-Enhanced Tools\n[6] \n[7] -   Authors: Peli de Halleux, Michał Moskal, Ben Zorn\n[8] -   Date: October 2023\n[9] -   Repository: [gptools](https://github.com/microsoft/gptools/tree/main)\n[10] \n[11] ## Abstract\n[12] \n[13] gptools is a framework that empowers teams, including non-developers, to create and use AI-enhanced scripts to support their workflows. gptools provides support for creating, understanding, and maintaining complex collections of documents such as software repositories, project management, etc. Our framework leverages foundation models (specifically LLMs) to enable a new kind of scripting that combines traditional code and natural language. The key elements of the gptools framework are **gpspecs** and **gptools**. gpspecs are natural language documents that describe specific user tasks to accomplish. gptools are general scripts that combine traditional software and natural language prompts and rely on an LLM to generate results. We execute gptools in the context of a gpspec to achieve a result. By separating these two abstractions, we allow gptools to be authored, maintained, and updated independently of the gpspecs that use them. The gptools framework includes an execution engine to execute a gptool and an IDE extension to VS Code to support user interaction with the gptool. We believe that gptools will empower even non-developers to automate their workflows in ways that were previously impossible.\n[14] \n[15] ## Introduction\n[16] \n[17] This document describes the gptools framework, which empowers teams, including non-developers, to use AI-enhanced scripts to support their efforts in creating, understanding, and maintaining complex artifacts. gptools leverages foundation models (LLMs) to enable a new kind of scripting that combines traditional code and natural language. To understand how gptools works, we provide an example. The key elements of gptools include gpspecs, gptools, the gpvm, and the gptools extension to VS code.\n[18] \n[19] ```mermaid\n[20] graph LR\n[21] F[User:\\nvia VSCode\\n UI] --> G[gpspec:\\nwrite email\\n recognizer]\n[22] G --> A[gptool:\\ngenerate\\npython code]\n[23] A --> C[gpvm pre:\\nexpand gpspec\\nand gptool\\ninto prompt]\n[24] C --> D[Foundation Model]\n[25] D --> E[gpvm post:\\nextract\\npython code]\n[26] E --> F\n[27] ```\n[28] \n[29] This diagram illustrates the workflow of gptools with a concrete example. The user wants to write a python function that recognizes well-formed email addresses and writes a gpspec. She then invokes a gptool, one that will generate python code from a spec, on that gpspec, much as a user might call a python script with some arguments. The gpvm composes the gpspec with the gptool creating an LLM prompt, which in turn is passed to the foundation model. The foundation model returns a result (python code) to the gpvm, which postprocesses it, creates the requested python file, and notifies the user.\n[30] \n[31] This document will motivate the design of the gptools framework, illustrate its use with examples, and describe elements of implementation.\n[32] \n[33] ## Complex Artifacts Require Complex Workflows\n[34] \n[35] -   Software development is a complex process that requires the coordination of many different activities.\n[36] -   Historically, software development has been a highly manual process, with developers using a variety of tools to create and maintain the artifacts that comprise a software system.\n[37] -   Over time abstractions have been developed to help manage the complexity of software development.\n[38]     -   Important examples include: Unix utilities and pipes, makefiles, build scripts, etc.\n[39] -   Modern software development includes many automated processes as well as manual processes such as code review, design review, bug triage, etc.\n[40] \n[41] ## Foundation Models Create New Opportunities\n[42] \n[43] -   The recent development of foundation models (aka LLMs) have created new opportunities for automating complex workflows.\n[44] -   AI has important advantages over traditional software:\n[45]     -   AI models can perform tasks normal software cannot\n[46]     -   AI models can be instructed using natural language, allowing non-programmers to use them\n[47] -   AI models also have disadvantages:\n[48]     -   AI models are not perfect, and can make mistakes\n[49]     -   AI models are not transparent, and it is difficult to understand why they make the decisions they do\n[50] -   AI models are best used to augment human workflows, not replace them\n[51] \n[52] ## gptools - a Framework for AI-Enhanced Workflows\n[53] \n[54] Vision: empower teams, including non-developers, to use AI-enhanced scripts to support their efforts to create, understand, and maintain complex artifacts\n[55] \n[56] Goals: support tool abstraction, modularity, reuse, but at the same time empower non-developers to author, maintain, and update AI-enhanced scripts\n[57] \n[58] Approach: Foundation models enable a new kind of scripting that allows script writers to achieve both greater functionality and greater ease of use. We separate scripts into two related parts: a generic reusable _gptool_ and a natural language _gpspec_ that instantiates the gptool in a particular context\n[59] \n[60] Key elements of gptools:\n[61] \n[62] -   _gptools_ – Scripts that integrate traditional code and natural language and leverage foundation models in their execution\n[63] -   _gpspecs_ – Natural language documents that instantiate gptools in a particular context\n[64] -   _gpvm_ – A framework and runtime system that executes gpspecs and gptools\n[65] -   _gptools extension to VS code_ – supporting seamless user interaction with gptools\n[66] \n[67] ## gptool: A New Kind of Script\n[68] \n[69] -   A gptool is a script with the following components\n[70] \n[71]     -   A header that contains metadata related to the execution of the script (e.g., information about what LLM model to use, etc.)\n[72]     -   A natural language prompt intended to be processed by a foundation model\n[73]     -   An environment context that augments the natural language with additional data/information\n[74]     -   Programming language constructs that are used to programmatically manipulate both inputs and outputs\n[75] \n[76] -   Benefits of gptools\n[77]     -   By separating the gptool from the gpspec, we allow gptools to become highly engineered shared artifacts, forming the basis of shared libraries.\n[78]     -   A gptool can be used in many different contexts, and can be updated and maintained independently of the gpspecs that use it.\n[79]     -   By separating the gptool from the gpspec, we allow non-developers to use gptools without having to understand the details of how they work.\n[80]     -   At the same time, because a gptool contains a natural language prompt, it is easy for a non-developer to understand what the gptool does, and to modify it to suit their needs.\n[81] \n[82] ## gpspec: Natural Language to Invoke a gptool\n[83] \n[84] Just as a chat enables a user to interact with an AI model, a gpspec is a natural language markdown document that defines a context in which to invoke a gptool.\n[85] \n[86] A gpspec is a standard markdown file, with the following additional elements:\n[87] \n[88] -   Links to context elements that define the context in which a particular gptool is to be invoked. For example, a gpspec might contain links to markdown files, code files, etc.\n[89] -   Natural language describing the specific task to be performed as input to a gptool. For example, the spec used to generate code would include a description of the functionality and might include a description style guidelines to observe, etc.\n[90] \n[91] . A single gpspec file might be used as input to multiple gptools. For example, a gpspec might be used to generate code, documentation, and tests, each using a different gptool.\n[92] \n[93] ## Expanding the Example\n[94] \n[95] To better understand how gptools work, we expand the example given above. The diagram below illustrates the gptools workflow in greater detail. Our design of gptools is based on the following principles:\n[96] \n[97] -   gptools are used in a context where there is human oversight on the content generated. As a result, our workflow starts and ends with the user.\n[98] -   We assume that the output of a gptool may be incomplete or incorrect, and that the user will need to interact with the output to refine it. As a result, we allow the user to accept/reject and directly modify the AI-generated content.\n[99] -   We assume that the user will want to understand how the AI model was used to generate the results. We provide a trace of how the gpvm composes the gpspec and gptool into a prompt that can be processed by the foundation model.\n[100] -   We support iterative development, where the user can both edit the gpspec and the gptool if they see opportunities to improve the results.\n[101] \n[102] ```mermaid\n[103] sequenceDiagram\n[104] participant User\n[105] participant VSCode\n[106] participant gpspec\n[107] participant gptool\n[108] participant gpvm\n[109] User->>VSCode: Create/Edit gpspec\n[110] VSCode->>gpspec: Save gpspec\n[111] User->>VSCode: Invoke gptool\n[112] VSCode->>gptool: Execute gptool with gpspec context\n[113] gptool->>gpvm: Request foundation model execution\n[114] gpvm->>gptool: Return AI-generated output\n[115] gptool->>VSCode: Update context with output\n[116] VSCode->>User: Display updated context\n[117] ```\n[118] \n[119] This diagram demonstrates the AI-enhanced workflow process in gptools. The gpspec instantiates the gptool, which interacts with the gpvm and foundation model. The AI-generated output is used to update the context, and the user interacts with the updated context through the gptools extension to VS code.\n[120] \n[121] ### gptool Example: Python Developer gptool\n[122] \n[123] This is an example of a simple gptool that generates python code from a gpspec file:\n[124] \n[125] ```javascript\n[126] gptool({\n[127]     title: \"Generate python code\",\n[128]     model: \"gpt-4\",\n[129]     description: \"Given a task, generate python code.\",\n[130] })\n[131] \n[132] def(\n[133]     \"CODE\",\n[134]     env.links.filter(\n[135]         (f) => f.filename.endsWith(\".py\") && !f.filename.startsWith(\"test_\")\n[136]     )\n[137] )\n[138] def(\"TASK\", env.file)\n[139] \n[140] $`Generate python code for the task in TASK. Save code in CODE. If the CODE is already present, ensure that CODE matches the description in TASK and make changes to CODE if it does not.`\n[141] ```\n[142] \n[143] In this example we see the following elements:\n[144] \n[145] -   A header that contains metadata related to the execution of the script (e.g., information about what LLM model to use, etc.)\n[146] -   JavaScript code that manipulates the environment context, specifically by extracting only the python files from the context that do not start with \"test\\_\".\n[147] -   Variable definitions that allow the prompt to refer to elements in the context. TASK refers to the gpspec file, and CODE refers to the python files in the context.\n[148] -   Natural language that combines these elements.\n[149] \n[150] ### gpspec Example: Using the Python Developer gptool\n[151] \n[152] This is an example of a gpspec file that uses the python generating gptool shown above:\n[153] \n[154] ```markdown\n[155] # email address and URL recognizer\n[156] \n[157] Write a function that takes a string argument and returns true if the whole string is a valid email address, false otherwise.\n[158] ```\n[159] \n[160] In this example, there is no additional context needed to invoke the python developer gptool. In other cases, the gpspec file will contain links to additional context elements, such as markdown, code files, etc.\n[161] \n[162] ## gpvm - A Framework for Executing gpspecs and gptools\n[163] \n[164] Every system that interacts with a foundation model includes layers that transform user input into a prompt that can be processed by the foundation model, and layers that transform the output of the foundation model into a form that is useful to the user.\n[165] \n[166] -   gpvm is a runtime environment that:\n[167]     -   Captures the context defined by the gpspec\n[168]     -   Executes whatever code is present in the gptool (in the example above, the variables CODE and TASK are defined by executing JavaScript code)\n[169]     -   Expands the gpspec and natural language of the gptool into a prompt that can be processed by the foundation model\n[170]     -   Sends the results to the AI model\n[171]     -   Processes the results on return to update the user context (which might include creating files, updating files, generating user feedback, etc.)\n[172] \n[173] Unlike many AI model orchestration frameworks, such as Semantic Kernel, gpvm does not leverage the model to do chain-of-thought reasoning or utomatically stage multiple invocations of the AI model during its execution. gptools currently relies on the user to choose and invoke the appropriate gptool as needed.\n[174] \n[175] ## gptools Extension to VS Code\n[176] \n[177] We believe that human oversight of AI models is essential to their effective use. To support this, we have created a VS Code extension that allows a user to interact with a gpspec and gptool in a natural way.\n[178] \n[179] The extension provides the following capabilities:\n[180] \n[181] -   A command palette that allows a user to select a gptool to invoke in the context of a given gpspec file\n[182] -   A token management system that supports connecting with the AI model of interest\n[183] -   An invocation of the gpvm to process the user input and generate results\n[184] -   A user interface that allows the user to interact with the AI model to refine the results\n[185] -   A gptool trace viewing mechanism that allows users to understand how the AI model was used to generate the results\n[186] \n[187] ## Implications of gptools\n[188] \n[189] The existence of powerful programming tools based on AI that are usable by non-developers is transformative.\n[190] \n[191] Just as the development of JavaScript enabled Web 2.0, and python enabled the creation of the current AI software ecosystem, gptools will fuel a new generation of AI-enhanced applications.\n[192] \n[193] We envision the creation of gptools for many different verticals, with opportunities for customization and authoring at many levels of expertise:\n[194] \n[195] -   Professional developers and architects will define collections of gptools for a given vertical just as packages are authored and maintained today\n[196] -   Professional developers can author and maintain individual gptools\n[197] -   Developers and non-developers can customize gptools for their particular organization or application needs\n[198] -   Non-developers can author and maintain gpspecs for their particular projects\n[199] \n[200] Furthermore, the existence of gptools can empower non-developers to automate their workflows in ways that were previously impossible.\n[201] \n[202] ## Related Work\n[203] \n[204] gptools are related to a number of foundation model projects that automate workflows and encapsulate LLM actions in software artifacts. We describe some of these projects below:\n[205] \n[206] ### AI Tools for Developers\n[207] \n[208] -   [GitHub Copilot](https://copilot.github.com/) is a VS Code extension that uses the Codex LLM to suggest code completions based on the context of the current file. Copilot provides LLM support for writing code but does not currently have an extensibility model or a way to create, maintain and apply collections of AI-enhanced scripts.\n[209] -   [codeplan](https://arxiv.org/abs/2309.12499) is a task-agnostic framework that frames repository-level coding as a planning problem, synthesizing a multi-step chain of edits where each step results in a call to an LLM on a code location with context derived from the entire repository, previous code changes, and task-specific instructions. While codeplan uses LLM prompts to generate code, it does not provide a way to create, maintain and apply collections of AI-enhanced scripts.\n[210] \n[211] ### LLM Automation/Orchestration Frameworks\n[212] \n[213] -   [autogpt](https://github.com/Significant-Gravitas/AutoGPT) is an AI agent that utilizes a large language model to drive its actions and decisions. Unlike traditional language model applications, AutoGPT does not require repeated prompting by a human and can autonomously develop and manage tasks.\n[214] -   [langchain](https://www.langchain.com/) is a Python library designed to simplify the development of Natural Language Processing (NLP) applications using large language models. It provides a framework for connecting language models to other sources of data and allowing them to interact with their environment.\n[215] -   [semantic kernel](https://github.com/microsoft/semantic-kernel) is an open-source SDK that allows developers to easily integrate AI services with conventional programming languages such as C# and Python. It provides a framework for connecting language models to other sources of data, allowing them to interact with their environment and perform tasks autonomously.\n[216] -   [autogen](https://arxiv.org/abs/2308.08155) is a framework for simplifying the orchestration, optimization, and automation of large language model (LLM) workflows. It offers customizable and conversable agents that leverage LLMs while addressing their limitations by integrating with humans and tools and having conversations between multiple agents via automated chat.\n[217] \n[218] gptools differ from existing AI task automation frameworks in the following ways:\n[219] \n[220] -   gptools are designed to be authored, maintained, and applied by non-developers as well as developers.\n[221] -   gptools define a separation between the gptool and the gpspec that instantiates it, allowing for modularity, reuse, and easier understanding by non-developers.\n[222] -   gptools do not assume task automation and provide a user experience that integrates seamlessly with VS code.\n[223] -   The gptools UI exposes both the content and execution of each gptools to facilitate human oversight and understanding of how the AI model was used to generate the results.\n`````\n\nYou are a search engine optimization expert at creating front matter for markdown document.\n\nUpdate or generate front matter in FILE:\n- Update fields title, description and keywords as needed\n- use yaml format, do not use quotes\n- only 5 keywords or less\n- optimize for search engine optimization.\n- Do NOT modify the markdown content after the front matter\n\nIf no front matter is present, generate it.\n``````\n\n\n## AI Output\n\n\n``````markdown\nDIFF ./gptools-overview.md:\n```diff\n[1] ---\n[2] title: gptools: AI-Enhanced Tools for Workflow Automation\n[3] description: An in-depth look at gptools, a framework that enables teams to create AI-enhanced scripts for workflow automation.\n[4] keywords: gptools, AI-enhanced scripts, workflow automation, AI tools, foundation models\n[5] ---\n[6] # gptools: Empowering Human Workflows with AI-Enhanced Tools\n```\n\nSUMMARY:\n```\nThe title and description of the front matter in the file 'gptools-overview.md' were updated for better SEO. Keywords were added to improve searchability.\n```\n``````\n\n\n### Extracted Variables\n\n-   `DIFF ./gptools-overview.md`\n`````\n[1] ---\n[2] title: gptools: AI-Enhanced Tools for Workflow Automation\n[3] description: An in-depth look at gptools, a framework that enables teams to create AI-enhanced scripts for workflow automation.\n[4] keywords: gptools, AI-enhanced scripts, workflow automation, AI tools, foundation models\n[5] ---\n[6] # gptools: Empowering Human Workflows with AI-Enhanced Tools\n\n`````\n\n-   `SUMMARY`\n`````\nThe title and description of the front matter in the file 'gptools-overview.md' were updated for better SEO. Keywords were added to improve searchability.\n\n`````\n\n","text":"DIFF ./gptools-overview.md:\n```diff\n[1] ---\n[2] title: gptools: AI-Enhanced Tools for Workflow Automation\n[3] description: An in-depth look at gptools, a framework that enables teams to create AI-enhanced scripts for workflow automation.\n[4] keywords: gptools, AI-enhanced scripts, workflow automation, AI tools, foundation models\n[5] ---\n[6] # gptools: Empowering Human Workflows with AI-Enhanced Tools\n```\n\nSUMMARY:\n```\nThe title and description of the front matter in the file 'gptools-overview.md' were updated for better SEO. Keywords were added to improve searchability.\n```","summary":"The title and description of the front matter in the file 'gptools-overview.md' were updated for better SEO. Keywords were added to improve searchability.\n"}}}
