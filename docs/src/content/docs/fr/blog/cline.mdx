---
title: √âcrire des workflows GenAIScript plus rapidement avec des assistants de codage
date: 2025-06-17
authors: volkanunsal
tags:
  - automation
  - cline
  - coding-assistants
cover:
  alt: "A pixelated 2D illustration of a computer workstation in a corporate
    theme. The centerpiece is a monitor showing TypeScript code snippets, where
    JSDoc comments stand out clearly above corresponding functions in blocky
    text format. Around the monitor are minimalist, geometric icons: a gear
    symbolizing workflow, a tree structure signifying abstract syntax trees, and
    a lightning bolt representing optimization and automation. The backdrop
    features a tidy grid pattern, utilizing a muted palette of five professional
    colors. The scene is clean and devoid of human figures or written labels."
  image: ../../blog/cline.png
excerpt: La documentation du code peut √™tre fastidieuse mais elle reste
  essentielle pour maintenir la qualit√© et faciliter la collaboration. Avec
  GenAIScript, vous pouvez automatiser la g√©n√©ration de commentaires JSDoc dans
  les projets TypeScript en utilisant ast-grep pour une analyse pr√©cise du code
  et les LLM pour produire une documentation d√©taill√©e. Cette approche permet
  non seulement de gagner du temps, mais aussi d'am√©liorer la coh√©rence et
  d'assurer la clart√© dans toute votre base de code. Des avantages pratiques
  comme l'ex√©cution parall√®le des t√¢ches, l'utilisation optimis√©e des prompts et
  la facilit√© de partage des workflows font de GenAIScript un outil puissant
  pour industrialiser ces t√¢ches au sein des √©quipes de d√©veloppement.

---

***

import BlogNarration from "../../../../components/BlogNarration.astro";

<BlogNarration />

## Introduction

GenAIScript facilite la prise en main pour coder des workflows LLM. Cependant, il peut √™tre difficile de l'utiliser efficacement pour √©crire des workflows complexes, car les techniques avanc√©es et les optimisations de performance peuvent √™tre hors de port√©e de nombreux d√©veloppeurs. Dans cet article, nous allons explorer comment les assistants de codage peuvent nous aider √† √©crire des workflows GenAIScript avanc√©s plus rapidement et avec moins d'effort.

## La t√¢che

Documenter du code existant est une t√¢che courante dans le d√©veloppement logiciel. Cela peut √™tre chronophage et est souvent n√©glig√©. Pourtant, cela est essentiel pour maintenir la qualit√© du code et s'assurer que le code est compr√©hensible par d'autres d√©veloppeurs.

Notre objectif aujourd'hui est d'√©crire un workflow GenAIScript qui ajoute automatiquement des commentaires JSDoc au code TypeScript qui n'en poss√®de pas encore.

Le script utilisera les fonctions AST grep pour rechercher dans le code, puis utilisera un grand mod√®le de langage pour g√©n√©rer des commentaires JSDoc pour le code, et modifiera le code pour y ajouter les commentaires en place.

AST grep est une fonctionnalit√© avanc√©e de GenAIScript qui nous permet de rechercher des motifs sp√©cifiques dans l'arbre syntaxique abstrait (AST) du code. C'est beaucoup plus efficace que d'utiliser les LLM pour analyser le code, car cela nous permet de trouver rapidement des segments de code qui correspondent √† des crit√®res sp√©cifiques.

Peli a explor√© cette fonctionnalit√© dans son article [AST Grep and Transform](https://microsoft.github.io/genaiscript/blog/ast-grep-and-transform/), et nous allons nous appuyer sur cela pour cr√©er notre script.

Voici un exemple de ce que nous souhaitons accomplir :

```ts wrap
// Before
function calculateTotal(price: number, tax: number): number {
  return price + price * tax;
}

// After
/**
 * Calculates the total amount including tax
 * @param {number} price - The base price
 * @param {number} tax - The tax rate as a decimal
 * @returns {number} The total amount including tax
 */
function calculateTotal(price: number, tax: number): number {
  return price + price * tax;
}
```

## Pourquoi GenAIScript et pas l'agent de codage ?

Il y a plusieurs raisons pour lesquelles GenAIScript est un meilleur choix que l'utilisation d'assistants de codage en mode agentique pour r√©aliser les m√™mes t√¢ches.

**Vitesse** : Les workflows GenAIScript peuvent √™tre ex√©cut√©s en parall√®le, ce qui peut significativement r√©duire le temps n√©cessaire pour terminer les t√¢ches. Imaginez attendre qu'un assistant de codage g√©n√®re du code pour un gros projet dans votre √©diteur, compar√© au lancement d'un workflow GenAIScript qui peut ex√©cuter plusieurs t√¢ches en arri√®re-plan. Que pr√©f√©reriez-vous ?

**Efficacit√© √©conomique** : GenAIScript vous donne un contr√¥le bas niveau sur vos invites, ce qui vous permet d‚Äôoptimiser celles-ci pour votre cas d‚Äôutilisation sp√©cifique. Cela signifie que vous pouvez r√©duire le nombre de jetons utilis√©s, ce qui peut vous faire √©conomiser de l‚Äôargent sur l‚Äôutilisation des LLM.

**Partageabilit√©** : Vous pouvez partager vos workflows GenAIScript avec d‚Äôautres d√©veloppeurs de votre √©quipe. Vous pensez peut-√™tre : ¬´ Mais je peux aussi partager mes invites d‚Äôassistant de codage ! ¬ª Cependant, les workflows GenAIScript sont plus que de simples invites ; ce sont des scripts autonomes qui encha√Ænent plusieurs appels LLM pour effectuer une t√¢che sp√©cifique. Cela les rend plus puissants et flexibles qu‚Äôune simple invite.

## Installation

Nous utiliserons Cline pour √©crire notre code GenAIScript. Mais vous pouvez utiliser n‚Äôimporte quel assistant de codage, y compris Github Copilot, Cursor ou Windsurf.

Tout d‚Äôabord, installons Cline depuis le Marketplace de VS Code.

![Installation de Cline](../../blog/cline-1.png)

Ensuite, nous configurerons Cline avec nos identifiants. Si vous utilisez Bedrock, comme moi, vous devrez d√©finir les variables d‚Äôenvironnement `AWS_ACCESS_KEY_ID` et `AWS_SECRET_ACCESS_KEY` dans votre terminal.

![Configuration du projet Cline](../../blog/cline-2.png)

Maintenant, nous sommes pr√™ts √† √©crire notre code GenAIScript. Nous ouvrirons notre projet et le pr√©parerons pour le d√©veloppement GenAIScript. Cela implique de cr√©er un nouveau fichier script. Je cr√©e toujours un fichier appel√© poem.

![Configuration GenAIScript](../../blog/cline-3.png)

Enfin, nous √©crirons une invite pour que Cline g√©n√®re le code GenAIScript. L‚Äôinvite d√©crira la t√¢che que nous voulons accomplir, et Cline g√©n√©rera le code pour nous.

## L‚Äôinvite

Voici l‚Äôinvite que j‚Äôai √©crite pour Cline afin de g√©n√©rer le code GenAIScript. Elle est con√ßue pour √™tre claire et concise, tout en fournissant suffisamment de d√©tails pour que Cline comprenne la t√¢che.

```md wrap
You are an expert software engineer, familiar in all aspects of TypeScript and GenAIScript. You will find the documentation for GenAIScript at https://microsoft.github.io/genaiscript/llms.txt. Make sure to follow the links in all the Documentation Sets to understand the full capabilities of GenAIScript before writing the script.

## Task

Your task is to write a GenAIScript script called that searches for the code in a path specified by the user using the AST grep functions, looking for functions, classes, and methods that do not have JSDoc comments. Use AST grep search functionality to perform the search.

For each function, class, or method found, the script invokes a large language model call to generate JSDoc comments that explain the code, with examples of how to use it.

The script then takes the output of this call and modifies the code to add the JSDoc comments in place, prepending the comments above the source code.

## Guidelines

The source code is written in TypeScript ESM for node.js v20+.

## Output Format

- Output a single GenAIScript script file. The file name should be `jsdoc-commentator.genai.mts`.
```

## Analyse de l‚Äôinvite

L‚Äôinvite utilise plusieurs techniques pour s‚Äôassurer que le script g√©n√©r√© r√©pond √† nos exigences :

1. **Expertise** : L‚Äôinvite sp√©cifie que l‚Äôassistant doit √™tre un expert en TypeScript et GenAIScript, ce qui garantit que le code g√©n√©r√© sera de haute qualit√©.
2. **Documentation** : L‚Äôinvite fournit un lien vers la documentation GenAIScript, permettant √† l‚Äôassistant de comprendre toutes les capacit√©s de GenAIScript et de les utiliser efficacement.
3. **D√©finition de la t√¢che** : L‚Äôinvite d√©finit clairement la t√¢che, y compris les exigences sp√©cifiques pour rechercher du code sans commentaires JSDoc et g√©n√©rer des commentaires √† l‚Äôaide d‚Äôun grand mod√®le de langage.
4. **Directives** : L‚Äôinvite pr√©cise que le code source est √©crit en TypeScript ESM pour node.js v20+, ce qui garantit que le code g√©n√©r√© sera compatible avec notre projet.
5. **Format de sortie** : L‚Äôinvite sp√©cifie le format de sortie, y compris le nom du fichier et la structure attendue du script.

## R√©sultats

Apr√®s avoir √©crit l‚Äôinvite, nous utilisons Cline pour g√©n√©rer le code GenAIScript. Cline analysera l‚Äôinvite et g√©n√©rera un script qui r√©pond √† nos exigences.

Voici le script que Cline a g√©n√©r√© pour moi (votre script peut l√©g√®rement varier) :

```ts wrap
import { astGrep } from "@genaiscript/plugin-ast-grep";

script({
  title: "Add JSDoc Comments to TypeScript Code",
  description:
    "Automatically generates JSDoc comments for TypeScript functions, classes, methods, and interfaces that are missing documentation",
  model: "large",
  parameters: {
    glob: {
      type: "string",
      description:
        "Glob pattern for TypeScript files to process",
      default: "**/*.{ts,tsx}",
    },
    updateExisting: {
      type: "boolean",
      description: "Update existing JSDoc comments",
      default: false,
    },
    applyEdits: {
      type: "boolean",
      description: "Apply the edits automatically",
      default: false,
    },
  },
});

// Find TypeScript files to process
const files = await workspace.findFiles(
  env.vars.glob || "**/*.{ts,tsx}",
  {
    ignore: ["**/node_modules/**", "**/dist/**", "**/*.d.ts"],
  },
);

if (files.length === 0) {
  env.output.log(
    `No TypeScript files found matching pattern: ${env.vars.glob || "**/*.{ts,tsx}"}`,
  );
  cancel("No files to process");
}

env.output.log(
  `Found ${files.length} TypeScript files to analyze for missing JSDoc comments.`,
);

// Define ast-grep patterns to find declarations without JSDoc
const astPatterns = [
  // Function declarations
  {
    name: "function_declaration",
    pattern: {
      rule: {
        kind: "export_statement",
        has: {
          kind: "function_declaration",
          has: {
            kind: "identifier",
            field: "name",
          },
        },
        not: {
          follows: {
            kind: "comment",
            stopBy: "neighbor",
          },
        },
      } satisfies SgRule,
    },
    description: "function declaration",
  },
  // Interface declarations
  {
    name: "interface_declaration",
    pattern: {
      rule: {
        kind: "export_statement",
        has: {
          kind: "interface_declaration",
          has: {
            kind: "type_identifier",
            field: "name",
          },
        },
        not: {
          follows: {
            kind: "comment",
            stopBy: "neighbor",
          },
        },
      } satisfies SgRule,
    },
    description: "interface declaration",
  },
  // Method definitions in classes
  {
    name: "method_definition",
    pattern: {
      rule: {
        kind: "method_definition",
        not: {
          follows: {
            kind: "comment",
            stopBy: "neighbor",
          },
        },
      } satisfies SgRule,
    },
    description: "method declaration",
  },
  // Arrow functions assigned to variables
  {
    name: "arrow_function",
    pattern: {
      rule: {
        kind: "export_statement",
        has: {
          kind: "lexical_declaration",
          has: {
            kind: "variable_declarator",
            has: {
              kind: "arrow_function",
              field: "value",
            },
          },
        },
        not: {
          follows: {
            kind: "comment",
            stopBy: "neighbor",
          },
        },
      } satisfies SgRule,
    },
    description: "arrow function",
  },
  // Type aliases
  {
    name: "type_alias",
    pattern: {
      rule: {
        kind: "export_statement",
        has: {
          kind: "type_alias_declaration",
          has: {
            kind: "type_identifier",
            field: "name",
          },
        },
        not: {
          follows: {
            kind: "comment",
            stopBy: "neighbor",
          },
        },
      } satisfies SgRule,
    },
    description: "type alias declaration",
  },
];

type Target = {
  match: SgNode; // The original match object for reference
};
const allTargets: Target[] = [];

// Get ast-grep instance
const sg = await astGrep();

// Process each file using ast-grep
for (const file of files) {
  // Check each ast-grep pattern
  for (const astPattern of astPatterns) {
    try {
      const targets: Target[] = [];
      // Use ast-grep to find matches
      const { matches } = await sg.search(
        "ts",
        file.filename,
        astPattern.pattern,
      );
      const edits = sg.changeset();

      for (const match of matches) {
        targets.push({
          match: match,
        });
      }

      await processTargets(edits, targets);
    } catch (error) {
      console.error(
        `Error processing pattern ${astPattern.name}:`,
        error,
      );
      // Continue with next pattern
    }
  }
}

if (allTargets.length === 0) {
  env.output.log(
    "‚úÖ All TypeScript declarations already have JSDoc comments or no declarations found.",
  );
  cancel("No work needed");
}

env.output.log(
  `Found ${allTargets.length} TypeScript declarations missing JSDoc comments.`,
);

if (!env.vars.applyEdits) {
  env.output.heading(2, "Preview Mode");
  env.output.log(
    "Set `applyEdits: true` to automatically apply the generated JSDoc comments to your source files.",
  );
}

async function processTargets(
  edits: SgChangeSet,
  targets: Target[],
) {
  allTargets.push(...targets);
  // Generate JSDoc for each target using inline prompts
  for (const target of targets) {
    const codeText = target.match.text();

    // Generate JSDoc comment for this specific declaration
    const jsdocComment = await runPrompt(
      (ctx) => {
        ctx.def("CODE", codeText);
        ctx.$`Generate a JSDoc comment for <CODE>. 

Requirements:
- Use proper JSDoc syntax with /** */
- Include appropriate tags (@param, @returns, @throws, etc.)
- Write clear, concise descriptions
- Return ONLY the JSDoc comment block, no other text or code`;
      },
      { model: "large", temperature: 0.1 },
    );

    // Extract the JSDoc comment from the response
    const jsdoc =
      parsers.unfence(jsdocComment.text, "typescript") ||
      jsdocComment.text;

    // Prepend the JSDoc comment to the code
    const newCode = jsdoc + "\n" + codeText;

    if (env.vars.applyEdits) {
      // Apply the edit to add JSDoc comment using changeset
      edits.replace(target.match, newCode);
    } else {
      // Preview mode - show what would be generated
      env.output.heading(4, "JSDoc Comment with Code");
      env.output.fence(newCode, "typescript");
    }
  }

  const modifiedFiles = edits.commit();
  await workspace.writeFiles(modifiedFiles);
}

if (env.vars.applyEdits) {
  env.output.log(
    `‚úÖ Successfully added JSDoc comments to ${allTargets.length} TypeScript declarations.`,
  );
} else {
  env.output.log(
    `üìã Preview complete. Found ${allTargets.length} declarations that need JSDoc comments.`,
  );
  env.output.log(
    "To apply these changes, run the script with `applyEdits: true`.",
  );
}
```

## Ex√©cution du script

Pour ex√©cuter le script, il faut le lancer dans notre terminal. Assurez-vous que GenAIScript est bien install√© et configur√©.

```sh wrap
npx genaiscript run jsdoc-commentator.genai.mts
```

## Conclusion

Dans cet article, nous avons explor√© comment les assistants de codage peuvent nous aider √† √©crire des workflows GenAIScript plus rapidement et avec moins d‚Äôeffort. Nous avons utilis√© Cline pour g√©n√©rer un script qui ajoute automatiquement des commentaires JSDoc au code TypeScript qui n‚Äôen avait pas encore. Nous avons √©galement discut√© des avantages d‚Äôutiliser GenAIScript plut√¥t que des assistants de codage en mode agent pour cette t√¢che.
